// @ts-nocheck
/**
 * Nexus Repository Manager REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 3.26.1-02
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url'
import { Configuration } from './configuration'
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios'
// Some imports not used depending on template conditions
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from './base'

/**
 *
 * @export
 * @interface AbstractApiRepository
 */
export interface AbstractApiRepository {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof AbstractApiRepository
   */
  name?: string
  /**
   * Component format held in this repository
   * @type {string}
   * @memberof AbstractApiRepository
   */
  format?: string
  /**
   * Controls if deployments of and updates to artifacts are allowed
   * @type {string}
   * @memberof AbstractApiRepository
   */
  type?: AbstractApiRepositoryTypeEnum
  /**
   * URL to the repository
   * @type {string}
   * @memberof AbstractApiRepository
   */
  url?: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof AbstractApiRepository
   */
  online: boolean
}

/**
 * @export
 * @enum {string}
 */
export enum AbstractApiRepositoryTypeEnum {
  Hosted = 'hosted',
  Proxy = 'proxy',
  Group = 'group',
}

/**
 *
 * @export
 * @interface AnonymousAccessSettingsXO
 */
export interface AnonymousAccessSettingsXO {
  /**
   * Whether or not Anonymous Access is enabled
   * @type {boolean}
   * @memberof AnonymousAccessSettingsXO
   */
  enabled?: boolean
  /**
   * The username of the anonymous account
   * @type {string}
   * @memberof AnonymousAccessSettingsXO
   */
  userId?: string
  /**
   * The name of the authentication realm for the anonymous account
   * @type {string}
   * @memberof AnonymousAccessSettingsXO
   */
  realmName?: string
}
/**
 *
 * @export
 * @interface ApiCertificate
 */
export interface ApiCertificate {
  /**
   *
   * @type {number}
   * @memberof ApiCertificate
   */
  expiresOn?: number
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  fingerprint?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  id?: string
  /**
   *
   * @type {number}
   * @memberof ApiCertificate
   */
  issuedOn?: number
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  issuerCommonName?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  issuerOrganization?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  issuerOrganizationalUnit?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  pem?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  serialNumber?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  subjectCommonName?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  subjectOrganization?: string
  /**
   *
   * @type {string}
   * @memberof ApiCertificate
   */
  subjectOrganizationalUnit?: string
}
/**
 *
 * @export
 * @interface ApiCreateUser
 */
export interface ApiCreateUser {
  /**
   * The userid which is required for login. This value cannot be changed.
   * @type {string}
   * @memberof ApiCreateUser
   */
  userId?: string
  /**
   * The first name of the user.
   * @type {string}
   * @memberof ApiCreateUser
   */
  firstName?: string
  /**
   * The last name of the user.
   * @type {string}
   * @memberof ApiCreateUser
   */
  lastName?: string
  /**
   * The email address associated with the user.
   * @type {string}
   * @memberof ApiCreateUser
   */
  emailAddress?: string
  /**
   * The password for the new user.
   * @type {string}
   * @memberof ApiCreateUser
   */
  password?: string
  /**
   * The user\'s status, e.g. active or disabled.
   * @type {string}
   * @memberof ApiCreateUser
   */
  status: ApiCreateUserStatusEnum
  /**
   * The roles which the user has been assigned within Nexus.
   * @type {Array<string>}
   * @memberof ApiCreateUser
   */
  roles?: Array<string>
}

/**
 * @export
 * @enum {string}
 */
export enum ApiCreateUserStatusEnum {
  Active = 'active',
  Locked = 'locked',
  Disabled = 'disabled',
  Changepassword = 'changepassword',
}

/**
 *
 * @export
 * @interface ApiEmailConfiguration
 */
export interface ApiEmailConfiguration {
  /**
   *
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  enabled?: boolean
  /**
   *
   * @type {string}
   * @memberof ApiEmailConfiguration
   */
  host?: string
  /**
   *
   * @type {number}
   * @memberof ApiEmailConfiguration
   */
  port: number
  /**
   *
   * @type {string}
   * @memberof ApiEmailConfiguration
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof ApiEmailConfiguration
   */
  password?: string
  /**
   *
   * @type {string}
   * @memberof ApiEmailConfiguration
   */
  fromAddress?: string
  /**
   * A prefix to add to all email subjects to aid in identifying automated emails
   * @type {string}
   * @memberof ApiEmailConfiguration
   */
  subjectPrefix?: string
  /**
   * Enable STARTTLS Support for Insecure Connections
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  startTlsEnabled?: boolean
  /**
   * Require STARTTLS Support
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  startTlsRequired?: boolean
  /**
   * Enable SSL/TLS Encryption upon Connection
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  sslOnConnectEnabled?: boolean
  /**
   * Verify the server certificate when using TLS or SSL
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  sslServerIdentityCheckEnabled?: boolean
  /**
   * Use the Nexus Repository Manager\'s certificate truststore
   * @type {boolean}
   * @memberof ApiEmailConfiguration
   */
  nexusTrustStoreEnabled?: boolean
}
/**
 *
 * @export
 * @interface ApiEmailValidation
 */
export interface ApiEmailValidation {
  /**
   *
   * @type {boolean}
   * @memberof ApiEmailValidation
   */
  success?: boolean
  /**
   *
   * @type {string}
   * @memberof ApiEmailValidation
   */
  reason?: string
}
/**
 *
 * @export
 * @interface ApiLicenseDetailsXO
 */
export interface ApiLicenseDetailsXO {
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  contactEmail?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  contactCompany?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  contactName?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  effectiveDate?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  expirationDate?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  licenseType?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  licensedUsers?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  fingerprint?: string
  /**
   *
   * @type {string}
   * @memberof ApiLicenseDetailsXO
   */
  features?: string
}
/**
 *
 * @export
 * @interface ApiPrivilege
 */
export interface ApiPrivilege {
  /**
   * The type of privilege, each type covers different portions of the system. External values supplied to this will be ignored by the system.
   * @type {string}
   * @memberof ApiPrivilege
   */
  type?: string
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilege
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilege
   */
  description?: string
  /**
   * Indicates whether the privilege can be changed. External values supplied to this will be ignored by the system.
   * @type {boolean}
   * @memberof ApiPrivilege
   */
  readOnly?: boolean
}
/**
 *
 * @export
 * @interface ApiPrivilegeApplicationRequest
 */
export interface ApiPrivilegeApplicationRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeApplicationRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeApplicationRequest
   */
  description?: string
  /**
   * A collection of actions to associate with the privilege, using BREAD syntax (browse,read,edit,add,delete,all) as well as \'run\' for script privileges.
   * @type {Array<string>}
   * @memberof ApiPrivilegeApplicationRequest
   */
  actions?: Array<ApiPrivilegeApplicationRequestActionsEnum>
  /**
   * The domain (i.e. \'blobstores\', \'capabilities\' or even \'*\' for all) that this privilege is granting access to.  Note that creating new privileges with a domain is only necessary when using plugins that define their own domain(s).
   * @type {string}
   * @memberof ApiPrivilegeApplicationRequest
   */
  domain?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ApiPrivilegeApplicationRequestActionsEnum {
  READ = 'READ',
  BROWSE = 'BROWSE',
  EDIT = 'EDIT',
  ADD = 'ADD',
  DELETE = 'DELETE',
  RUN = 'RUN',
  ASSOCIATE = 'ASSOCIATE',
  DISASSOCIATE = 'DISASSOCIATE',
  ALL = 'ALL',
}

/**
 *
 * @export
 * @interface ApiPrivilegeRepositoryAdminRequest
 */
export interface ApiPrivilegeRepositoryAdminRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeRepositoryAdminRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeRepositoryAdminRequest
   */
  description?: string
  /**
   * A collection of actions to associate with the privilege, using BREAD syntax (browse,read,edit,add,delete,all) as well as \'run\' for script privileges.
   * @type {Array<string>}
   * @memberof ApiPrivilegeRepositoryAdminRequest
   */
  actions?: Array<ApiPrivilegeRepositoryAdminRequestActionsEnum>
  /**
   * The repository format (i.e \'nuget\', \'npm\') this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryAdminRequest
   */
  format?: string
  /**
   * The name of the repository this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryAdminRequest
   */
  repository?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ApiPrivilegeRepositoryAdminRequestActionsEnum {
  READ = 'READ',
  BROWSE = 'BROWSE',
  EDIT = 'EDIT',
  ADD = 'ADD',
  DELETE = 'DELETE',
  RUN = 'RUN',
  ASSOCIATE = 'ASSOCIATE',
  DISASSOCIATE = 'DISASSOCIATE',
  ALL = 'ALL',
}

/**
 *
 * @export
 * @interface ApiPrivilegeRepositoryContentSelectorRequest
 */
export interface ApiPrivilegeRepositoryContentSelectorRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  description?: string
  /**
   * A collection of actions to associate with the privilege, using BREAD syntax (browse,read,edit,add,delete,all) as well as \'run\' for script privileges.
   * @type {Array<string>}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  actions?: Array<ApiPrivilegeRepositoryContentSelectorRequestActionsEnum>
  /**
   * The repository format (i.e \'nuget\', \'npm\') this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  format?: string
  /**
   * The name of the repository this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  repository?: string
  /**
   * The name of a content selector that will be used to grant access to content via this privilege.
   * @type {string}
   * @memberof ApiPrivilegeRepositoryContentSelectorRequest
   */
  contentSelector?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ApiPrivilegeRepositoryContentSelectorRequestActionsEnum {
  READ = 'READ',
  BROWSE = 'BROWSE',
  EDIT = 'EDIT',
  ADD = 'ADD',
  DELETE = 'DELETE',
  RUN = 'RUN',
  ASSOCIATE = 'ASSOCIATE',
  DISASSOCIATE = 'DISASSOCIATE',
  ALL = 'ALL',
}

/**
 *
 * @export
 * @interface ApiPrivilegeRepositoryViewRequest
 */
export interface ApiPrivilegeRepositoryViewRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeRepositoryViewRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeRepositoryViewRequest
   */
  description?: string
  /**
   * A collection of actions to associate with the privilege, using BREAD syntax (browse,read,edit,add,delete,all) as well as \'run\' for script privileges.
   * @type {Array<string>}
   * @memberof ApiPrivilegeRepositoryViewRequest
   */
  actions?: Array<ApiPrivilegeRepositoryViewRequestActionsEnum>
  /**
   * The repository format (i.e \'nuget\', \'npm\') this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryViewRequest
   */
  format?: string
  /**
   * The name of the repository this privilege will grant access to (or * for all).
   * @type {string}
   * @memberof ApiPrivilegeRepositoryViewRequest
   */
  repository?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ApiPrivilegeRepositoryViewRequestActionsEnum {
  READ = 'READ',
  BROWSE = 'BROWSE',
  EDIT = 'EDIT',
  ADD = 'ADD',
  DELETE = 'DELETE',
  RUN = 'RUN',
  ASSOCIATE = 'ASSOCIATE',
  DISASSOCIATE = 'DISASSOCIATE',
  ALL = 'ALL',
}

/**
 *
 * @export
 * @interface ApiPrivilegeScriptRequest
 */
export interface ApiPrivilegeScriptRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeScriptRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeScriptRequest
   */
  description?: string
  /**
   * A collection of actions to associate with the privilege, using BREAD syntax (browse,read,edit,add,delete,all) as well as \'run\' for script privileges.
   * @type {Array<string>}
   * @memberof ApiPrivilegeScriptRequest
   */
  actions?: Array<ApiPrivilegeScriptRequestActionsEnum>
  /**
   * The name of a script to give access to.
   * @type {string}
   * @memberof ApiPrivilegeScriptRequest
   */
  scriptName?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ApiPrivilegeScriptRequestActionsEnum {
  READ = 'READ',
  BROWSE = 'BROWSE',
  EDIT = 'EDIT',
  ADD = 'ADD',
  DELETE = 'DELETE',
  RUN = 'RUN',
  ASSOCIATE = 'ASSOCIATE',
  DISASSOCIATE = 'DISASSOCIATE',
  ALL = 'ALL',
}

/**
 *
 * @export
 * @interface ApiPrivilegeWildcardRequest
 */
export interface ApiPrivilegeWildcardRequest {
  /**
   * The name of the privilege.  This value cannot be changed.
   * @type {string}
   * @memberof ApiPrivilegeWildcardRequest
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ApiPrivilegeWildcardRequest
   */
  description?: string
  /**
   * A colon separated list of parts that create a permission string.
   * @type {string}
   * @memberof ApiPrivilegeWildcardRequest
   */
  pattern?: string
}
/**
 *
 * @export
 * @interface ApiUser
 */
export interface ApiUser {
  /**
   * The userid which is required for login. This value cannot be changed.
   * @type {string}
   * @memberof ApiUser
   */
  userId?: string
  /**
   * The first name of the user.
   * @type {string}
   * @memberof ApiUser
   */
  firstName?: string
  /**
   * The last name of the user.
   * @type {string}
   * @memberof ApiUser
   */
  lastName?: string
  /**
   * The email address associated with the user.
   * @type {string}
   * @memberof ApiUser
   */
  emailAddress?: string
  /**
   * The user source which is the origin of this user. This value cannot be changed.
   * @type {string}
   * @memberof ApiUser
   */
  source?: string
  /**
   * The user\'s status, e.g. active or disabled.
   * @type {string}
   * @memberof ApiUser
   */
  status: ApiUserStatusEnum
  /**
   * Indicates whether the user\'s properties could be modified by the Nexus Repository Manager. When false only roles are considered during update.
   * @type {boolean}
   * @memberof ApiUser
   */
  readOnly?: boolean
  /**
   * The roles which the user has been assigned within Nexus.
   * @type {Array<string>}
   * @memberof ApiUser
   */
  roles?: Array<string>
  /**
   * The roles which the user has been assigned in an external source, e.g. LDAP group. These cannot be changed within the Nexus Repository Manager.
   * @type {Array<string>}
   * @memberof ApiUser
   */
  externalRoles?: Array<string>
}

/**
 * @export
 * @enum {string}
 */
export enum ApiUserStatusEnum {
  Active = 'active',
  Locked = 'locked',
  Disabled = 'disabled',
  Changepassword = 'changepassword',
}

/**
 *
 * @export
 * @interface ApiUserSource
 */
export interface ApiUserSource {
  /**
   *
   * @type {string}
   * @memberof ApiUserSource
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ApiUserSource
   */
  name?: string
}
/**
 *
 * @export
 * @interface AptHostedRepositoriesAttributes
 */
export interface AptHostedRepositoriesAttributes {
  /**
   * Distribution to fetch
   * @type {string}
   * @memberof AptHostedRepositoriesAttributes
   */
  distribution?: string
}
/**
 *
 * @export
 * @interface AptHostedRepositoryApiRequest
 */
export interface AptHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof AptHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof AptHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof AptHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof AptHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {AptHostedRepositoriesAttributes}
   * @memberof AptHostedRepositoryApiRequest
   */
  apt: AptHostedRepositoriesAttributes
  /**
   *
   * @type {AptSigningRepositoriesAttributes}
   * @memberof AptHostedRepositoryApiRequest
   */
  aptSigning: AptSigningRepositoriesAttributes
}
/**
 *
 * @export
 * @interface AptProxyRepositoriesAttributes
 */
export interface AptProxyRepositoriesAttributes {
  /**
   * Distribution to fetch
   * @type {string}
   * @memberof AptProxyRepositoriesAttributes
   */
  distribution?: string
  /**
   * Whether this repository is flat
   * @type {boolean}
   * @memberof AptProxyRepositoriesAttributes
   */
  flat: boolean
}
/**
 *
 * @export
 * @interface AptProxyRepositoryApiRequest
 */
export interface AptProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof AptProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof AptProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof AptProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {AptProxyRepositoriesAttributes}
   * @memberof AptProxyRepositoryApiRequest
   */
  apt: AptProxyRepositoriesAttributes
}
/**
 *
 * @export
 * @interface AptSigningRepositoriesAttributes
 */
export interface AptSigningRepositoriesAttributes {
  /**
   * PGP signing key pair (armored private key e.g. gpg --export-secret-key --armor)
   * @type {string}
   * @memberof AptSigningRepositoriesAttributes
   */
  keypair?: string
  /**
   * Passphrase to access PGP signing key
   * @type {string}
   * @memberof AptSigningRepositoriesAttributes
   */
  passphrase?: string
}
/**
 *
 * @export
 * @interface AssetXO
 */
export interface AssetXO {
  /**
   *
   * @type {string}
   * @memberof AssetXO
   */
  downloadUrl?: string
  /**
   *
   * @type {string}
   * @memberof AssetXO
   */
  path?: string
  /**
   *
   * @type {string}
   * @memberof AssetXO
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof AssetXO
   */
  repository?: string
  /**
   *
   * @type {string}
   * @memberof AssetXO
   */
  format?: string
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof AssetXO
   */
  checksum?: { [key: string]: object }
}
/**
 *
 * @export
 * @interface BlobStoreApiSoftQuota
 */
export interface BlobStoreApiSoftQuota {
  /**
   * The type to use such as spaceRemainingQuota, or spaceUsedQuota
   * @type {string}
   * @memberof BlobStoreApiSoftQuota
   */
  type?: string
  /**
   * The limit in MB.
   * @type {number}
   * @memberof BlobStoreApiSoftQuota
   */
  limit?: number
}
/**
 *
 * @export
 * @interface BlobStoreQuotaResultXO
 */
export interface BlobStoreQuotaResultXO {
  /**
   *
   * @type {boolean}
   * @memberof BlobStoreQuotaResultXO
   */
  isViolation?: boolean
  /**
   *
   * @type {string}
   * @memberof BlobStoreQuotaResultXO
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof BlobStoreQuotaResultXO
   */
  blobStoreName?: string
}
/**
 *
 * @export
 * @interface BowerAttributes
 */
export interface BowerAttributes {
  /**
   * Whether to force Bower to retrieve packages through this proxy repository
   * @type {boolean}
   * @memberof BowerAttributes
   */
  rewritePackageUrls: boolean
}
/**
 *
 * @export
 * @interface BowerGroupRepositoryApiRequest
 */
export interface BowerGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof BowerGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof BowerGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof BowerGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof BowerGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface BowerHostedRepositoryApiRequest
 */
export interface BowerHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof BowerHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof BowerHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof BowerHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof BowerHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface BowerProxyRepositoryApiRequest
 */
export interface BowerProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof BowerProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof BowerProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof BowerProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {BowerAttributes}
   * @memberof BowerProxyRepositoryApiRequest
   */
  bower?: BowerAttributes
}
/**
 *
 * @export
 * @interface CleanupPolicyAttributes
 */
export interface CleanupPolicyAttributes {
  /**
   * Components that match any of the applied policies will be deleted
   * @type {Array<string>}
   * @memberof CleanupPolicyAttributes
   */
  policyNames?: Array<string>
}
/**
 *
 * @export
 * @interface CocoapodsProxyRepositoryApiRequest
 */
export interface CocoapodsProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof CocoapodsProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface ComponentXO
 */
export interface ComponentXO {
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  repository?: string
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  format?: string
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  group?: string
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ComponentXO
   */
  version?: string
  /**
   *
   * @type {Array<AssetXO>}
   * @memberof ComponentXO
   */
  assets?: Array<AssetXO>
}
/**
 *
 * @export
 * @interface ConanProxyRepositoryApiRequest
 */
export interface ConanProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof ConanProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof ConanProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof ConanProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof ConanProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof ConanProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof ConanProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof ConanProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof ConanProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface ContentSelectorApiCreateRequest
 */
export interface ContentSelectorApiCreateRequest {
  /**
   * The content selector name cannot be changed after creation
   * @type {string}
   * @memberof ContentSelectorApiCreateRequest
   */
  name?: string
  /**
   * A human-readable description
   * @type {string}
   * @memberof ContentSelectorApiCreateRequest
   */
  description?: string
  /**
   * The expression used to identify content
   * @type {string}
   * @memberof ContentSelectorApiCreateRequest
   */
  expression?: string
}
/**
 *
 * @export
 * @interface ContentSelectorApiResponse
 */
export interface ContentSelectorApiResponse {
  /**
   * The content selector name cannot be changed after creation
   * @type {string}
   * @memberof ContentSelectorApiResponse
   */
  name?: string
  /**
   * The type of content selector the backend is using
   * @type {string}
   * @memberof ContentSelectorApiResponse
   */
  type?: ContentSelectorApiResponseTypeEnum
  /**
   * A human-readable description
   * @type {string}
   * @memberof ContentSelectorApiResponse
   */
  description?: string
  /**
   * The expression used to identify content
   * @type {string}
   * @memberof ContentSelectorApiResponse
   */
  expression?: string
}

/**
 * @export
 * @enum {string}
 */
export enum ContentSelectorApiResponseTypeEnum {
  Csel = 'csel',
  Jexl = 'jexl',
}

/**
 *
 * @export
 * @interface ContentSelectorApiUpdateRequest
 */
export interface ContentSelectorApiUpdateRequest {
  /**
   * An optional description of this content selector
   * @type {string}
   * @memberof ContentSelectorApiUpdateRequest
   */
  description?: string
  /**
   * The expression used to identify content
   * @type {string}
   * @memberof ContentSelectorApiUpdateRequest
   */
  expression?: string
}
/**
 *
 * @export
 * @interface CreateLdapServerXo
 */
export interface CreateLdapServerXo {
  /**
   * LDAP server name
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  name: string
  /**
   * LDAP server connection Protocol to use
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  protocol: CreateLdapServerXoProtocolEnum
  /**
   * Whether to use certificates stored in Nexus Repository Manager\'s truststore
   * @type {boolean}
   * @memberof CreateLdapServerXo
   */
  useTrustStore?: boolean
  /**
   * LDAP server connection hostname
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  host: string
  /**
   * LDAP server connection port to use
   * @type {number}
   * @memberof CreateLdapServerXo
   */
  port: number
  /**
   * LDAP location to be added to the connection URL
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  searchBase: string
  /**
   * Authentication scheme used for connecting to LDAP server
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  authScheme: CreateLdapServerXoAuthSchemeEnum
  /**
   * The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  authRealm?: string
  /**
   * This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  authUsername?: string
  /**
   * How long to wait before timeout
   * @type {number}
   * @memberof CreateLdapServerXo
   */
  connectionTimeoutSeconds: number
  /**
   * How long to wait before retrying
   * @type {number}
   * @memberof CreateLdapServerXo
   */
  connectionRetryDelaySeconds: number
  /**
   * How many retry attempts
   * @type {number}
   * @memberof CreateLdapServerXo
   */
  maxIncidentsCount: number
  /**
   * The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userBaseDn?: string
  /**
   * Are users located in structures below the user base DN?
   * @type {boolean}
   * @memberof CreateLdapServerXo
   */
  userSubtree?: boolean
  /**
   * LDAP class for user objects
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userObjectClass?: string
  /**
   * LDAP search filter to limit user search
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userLdapFilter?: string
  /**
   * This is used to find a user given its user ID
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userIdAttribute?: string
  /**
   * This is used to find a real name given the user ID
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userRealNameAttribute?: string
  /**
   * This is used to find an email address given the user ID
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userEmailAddressAttribute?: string
  /**
   * If this field is blank the user will be authenticated against a bind with the LDAP server
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userPasswordAttribute?: string
  /**
   * Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
   * @type {boolean}
   * @memberof CreateLdapServerXo
   */
  ldapGroupsAsRoles?: boolean
  /**
   * Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupType: CreateLdapServerXoGroupTypeEnum
  /**
   * The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupBaseDn?: string
  /**
   * Are groups located in structures below the group base DN
   * @type {boolean}
   * @memberof CreateLdapServerXo
   */
  groupSubtree?: boolean
  /**
   * LDAP class for group objects. Required if groupType is static
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupObjectClass?: string
  /**
   * This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupIdAttribute?: string
  /**
   * LDAP attribute containing the usernames for the group. Required if groupType is static
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupMemberAttribute?: string
  /**
   * The format of user ID stored in the group member attribute. Required if groupType is static
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  groupMemberFormat?: string
  /**
   * Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  userMemberOfAttribute?: string
  /**
   * The password to bind with. Required if authScheme other than none.
   * @type {string}
   * @memberof CreateLdapServerXo
   */
  authPassword: string
}

/**
 * @export
 * @enum {string}
 */
export enum CreateLdapServerXoProtocolEnum {
  Ldap = 'ldap',
  Ldaps = 'ldaps',
}
/**
 * @export
 * @enum {string}
 */
export enum CreateLdapServerXoAuthSchemeEnum {
  NONE = 'NONE',
  SIMPLE = 'SIMPLE',
  DIGESTMD5 = 'DIGEST_MD5',
  CRAMMD5 = 'CRAM_MD5',
}
/**
 * @export
 * @enum {string}
 */
export enum CreateLdapServerXoGroupTypeEnum {
  Static = 'static',
  Dynamic = 'dynamic',
}

/**
 *
 * @export
 * @interface DockerAttributes
 */
export interface DockerAttributes {
  /**
   * Whether to allow clients to use the V1 API to interact with this repository
   * @type {boolean}
   * @memberof DockerAttributes
   */
  v1Enabled: boolean
  /**
   * Whether to force authentication (Docker Bearer Token Realm required if false)
   * @type {boolean}
   * @memberof DockerAttributes
   */
  forceBasicAuth: boolean
  /**
   * Create an HTTP connector at specified port
   * @type {number}
   * @memberof DockerAttributes
   */
  httpPort?: number
  /**
   * Create an HTTPS connector at specified port
   * @type {number}
   * @memberof DockerAttributes
   */
  httpsPort?: number
}
/**
 *
 * @export
 * @interface DockerGroupRepositoryApiRequest
 */
export interface DockerGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof DockerGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof DockerGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof DockerGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof DockerGroupRepositoryApiRequest
   */
  group: GroupAttributes
  /**
   *
   * @type {DockerAttributes}
   * @memberof DockerGroupRepositoryApiRequest
   */
  docker: DockerAttributes
}
/**
 *
 * @export
 * @interface DockerHostedRepositoryApiRequest
 */
export interface DockerHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof DockerHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof DockerHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof DockerHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof DockerHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {DockerAttributes}
   * @memberof DockerHostedRepositoryApiRequest
   */
  docker: DockerAttributes
}
/**
 *
 * @export
 * @interface DockerProxyAttributes
 */
export interface DockerProxyAttributes {
  /**
   * Type of Docker Index
   * @type {string}
   * @memberof DockerProxyAttributes
   */
  indexType?: DockerProxyAttributesIndexTypeEnum
  /**
   * Url of Docker Index to use
   * @type {string}
   * @memberof DockerProxyAttributes
   */
  indexUrl?: string
}

/**
 * @export
 * @enum {string}
 */
export enum DockerProxyAttributesIndexTypeEnum {
  HUB = 'HUB',
  REGISTRY = 'REGISTRY',
  CUSTOM = 'CUSTOM',
}

/**
 *
 * @export
 * @interface DockerProxyRepositoryApiRequest
 */
export interface DockerProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof DockerProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof DockerProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof DockerProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {DockerAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  docker: DockerAttributes
  /**
   *
   * @type {DockerProxyAttributes}
   * @memberof DockerProxyRepositoryApiRequest
   */
  dockerProxy: DockerProxyAttributes
}
/**
 *
 * @export
 * @interface FileBlobStoreApiCreateRequest
 */
export interface FileBlobStoreApiCreateRequest {
  /**
   *
   * @type {BlobStoreApiSoftQuota}
   * @memberof FileBlobStoreApiCreateRequest
   */
  softQuota?: BlobStoreApiSoftQuota
  /**
   * The path to the blobstore contents. This can be an absolute path to anywhere on the system Nexus Repository Manager has access to or it can be a path relative to the sonatype-work directory.
   * @type {string}
   * @memberof FileBlobStoreApiCreateRequest
   */
  path?: string
  /**
   *
   * @type {string}
   * @memberof FileBlobStoreApiCreateRequest
   */
  name?: string
}
/**
 *
 * @export
 * @interface FileBlobStoreApiModel
 */
export interface FileBlobStoreApiModel {
  /**
   *
   * @type {BlobStoreApiSoftQuota}
   * @memberof FileBlobStoreApiModel
   */
  softQuota?: BlobStoreApiSoftQuota
  /**
   * The path to the blobstore contents. This can be an absolute path to anywhere on the system Nexus Repository Manager has access to or it can be a path relative to the sonatype-work directory.
   * @type {string}
   * @memberof FileBlobStoreApiModel
   */
  path?: string
}
/**
 *
 * @export
 * @interface FileBlobStoreApiUpdateRequest
 */
export interface FileBlobStoreApiUpdateRequest {
  /**
   *
   * @type {BlobStoreApiSoftQuota}
   * @memberof FileBlobStoreApiUpdateRequest
   */
  softQuota?: BlobStoreApiSoftQuota
  /**
   * The path to the blobstore contents. This can be an absolute path to anywhere on the system Nexus Repository Manager has access to or it can be a path relative to the sonatype-work directory.
   * @type {string}
   * @memberof FileBlobStoreApiUpdateRequest
   */
  path?: string
}
/**
 *
 * @export
 * @interface GenericBlobStoreApiResponse
 */
export interface GenericBlobStoreApiResponse {
  /**
   *
   * @type {BlobStoreApiSoftQuota}
   * @memberof GenericBlobStoreApiResponse
   */
  softQuota?: BlobStoreApiSoftQuota
  /**
   *
   * @type {string}
   * @memberof GenericBlobStoreApiResponse
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof GenericBlobStoreApiResponse
   */
  type?: string
  /**
   *
   * @type {number}
   * @memberof GenericBlobStoreApiResponse
   */
  blobCount?: number
  /**
   *
   * @type {number}
   * @memberof GenericBlobStoreApiResponse
   */
  totalSizeInBytes?: number
  /**
   *
   * @type {number}
   * @memberof GenericBlobStoreApiResponse
   */
  availableSpaceInBytes?: number
}
/**
 *
 * @export
 * @interface GitLfsHostedRepositoryApiRequest
 */
export interface GitLfsHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof GitLfsHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof GitLfsHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof GitLfsHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof GitLfsHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface GolangGroupRepositoryApiRequest
 */
export interface GolangGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof GolangGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof GolangGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof GolangGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof GolangGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface GolangProxyRepositoryApiRequest
 */
export interface GolangProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof GolangProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof GolangProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof GolangProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof GolangProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof GolangProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof GolangProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof GolangProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof GolangProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface GroupAttributes
 */
export interface GroupAttributes {
  /**
   * Member repositories\' names
   * @type {Array<string>}
   * @memberof GroupAttributes
   */
  memberNames?: Array<string>
}
/**
 *
 * @export
 * @interface HelmHostedRepositoryApiRequest
 */
export interface HelmHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof HelmHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof HelmHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof HelmHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof HelmHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface HelmProxyRepositoryApiRequest
 */
export interface HelmProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof HelmProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof HelmProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof HelmProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof HelmProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof HelmProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof HelmProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof HelmProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof HelmProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface HostedStorageAttributes
 */
export interface HostedStorageAttributes {
  /**
   * Blob store used to store repository contents
   * @type {string}
   * @memberof HostedStorageAttributes
   */
  blobStoreName?: string
  /**
   * Whether to validate uploaded content\'s MIME type appropriate for the repository format
   * @type {boolean}
   * @memberof HostedStorageAttributes
   */
  strictContentTypeValidation: boolean
  /**
   * Controls if deployments of and updates to assets are allowed
   * @type {string}
   * @memberof HostedStorageAttributes
   */
  writePolicy: HostedStorageAttributesWritePolicyEnum
}

/**
 * @export
 * @enum {string}
 */
export enum HostedStorageAttributesWritePolicyEnum {
  Allow = 'allow',
  AllowOnce = 'allow_once',
  Deny = 'deny',
}

/**
 *
 * @export
 * @interface HttpClientAttributes
 */
export interface HttpClientAttributes {
  /**
   * Whether to block outbound connections on the repository
   * @type {boolean}
   * @memberof HttpClientAttributes
   */
  blocked: boolean
  /**
   * Whether to auto-block outbound connections if remote peer is detected as unreachable/unresponsive
   * @type {boolean}
   * @memberof HttpClientAttributes
   */
  autoBlock: boolean
  /**
   *
   * @type {HttpClientConnectionAttributes}
   * @memberof HttpClientAttributes
   */
  connection?: HttpClientConnectionAttributes
  /**
   *
   * @type {HttpClientConnectionAuthenticationAttributes}
   * @memberof HttpClientAttributes
   */
  authentication?: HttpClientConnectionAuthenticationAttributes
}
/**
 *
 * @export
 * @interface HttpClientConnectionAttributes
 */
export interface HttpClientConnectionAttributes {
  /**
   * Total retries if the initial connection attempt suffers a timeout
   * @type {number}
   * @memberof HttpClientConnectionAttributes
   */
  retries?: number
  /**
   * Custom fragment to append to User-Agent header in HTTP requests
   * @type {string}
   * @memberof HttpClientConnectionAttributes
   */
  userAgentSuffix?: string
  /**
   * Seconds to wait for activity before stopping and retrying the connection
   * @type {number}
   * @memberof HttpClientConnectionAttributes
   */
  timeout?: number
  /**
   * Whether to enable redirects to the same location (may be required by some servers)
   * @type {boolean}
   * @memberof HttpClientConnectionAttributes
   */
  enableCircularRedirects?: boolean
  /**
   * Whether to allow cookies to be stored and used
   * @type {boolean}
   * @memberof HttpClientConnectionAttributes
   */
  enableCookies?: boolean
}
/**
 *
 * @export
 * @interface HttpClientConnectionAuthenticationAttributes
 */
export interface HttpClientConnectionAuthenticationAttributes {
  /**
   * Authentication type
   * @type {string}
   * @memberof HttpClientConnectionAuthenticationAttributes
   */
  type?: HttpClientConnectionAuthenticationAttributesTypeEnum
  /**
   *
   * @type {string}
   * @memberof HttpClientConnectionAuthenticationAttributes
   */
  username?: string
  /**
   *
   * @type {string}
   * @memberof HttpClientConnectionAuthenticationAttributes
   */
  ntlmHost?: string
  /**
   *
   * @type {string}
   * @memberof HttpClientConnectionAuthenticationAttributes
   */
  ntlmDomain?: string
}

/**
 * @export
 * @enum {string}
 */
export enum HttpClientConnectionAuthenticationAttributesTypeEnum {
  Username = 'username',
  Ntlm = 'ntlm',
}

/**
 *
 * @export
 * @interface IqConnectionVerificationXo
 */
export interface IqConnectionVerificationXo {
  /**
   *
   * @type {boolean}
   * @memberof IqConnectionVerificationXo
   */
  success?: boolean
  /**
   *
   * @type {string}
   * @memberof IqConnectionVerificationXo
   */
  reason?: string
}
/**
 *
 * @export
 * @interface IqConnectionXo
 */
export interface IqConnectionXo {
  /**
   * Whether to use IQ Server
   * @type {boolean}
   * @memberof IqConnectionXo
   */
  enabled?: boolean
  /**
   * Show IQ Server link in Browse menu when server is enabled
   * @type {boolean}
   * @memberof IqConnectionXo
   */
  showLink?: boolean
  /**
   * The address of your IQ Server
   * @type {string}
   * @memberof IqConnectionXo
   */
  url?: string
  /**
   * Authentication method
   * @type {string}
   * @memberof IqConnectionXo
   */
  authenticationType: IqConnectionXoAuthenticationTypeEnum
  /**
   * User with access to IQ Server
   * @type {string}
   * @memberof IqConnectionXo
   */
  username?: string
  /**
   * Credentials for the IQ Server User
   * @type {string}
   * @memberof IqConnectionXo
   */
  password?: string
  /**
   * Use certificates stored in the Nexus Repository Manager truststore to connect to IQ Server
   * @type {boolean}
   * @memberof IqConnectionXo
   */
  useTrustStoreForUrl?: boolean
  /**
   * Seconds to wait for activity before stopping and retrying the connection. Leave blank to use the globally defined HTTP timeout.
   * @type {number}
   * @memberof IqConnectionXo
   */
  timeoutSeconds?: number
  /**
   * Additional properties to configure for IQ Server
   * @type {string}
   * @memberof IqConnectionXo
   */
  properties?: string
}

/**
 * @export
 * @enum {string}
 */
export enum IqConnectionXoAuthenticationTypeEnum {
  USER = 'USER',
  PKI = 'PKI',
}

/**
 *
 * @export
 * @interface MavenAttributes
 */
export interface MavenAttributes {
  /**
   * What type of artifacts does this repository store?
   * @type {string}
   * @memberof MavenAttributes
   */
  versionPolicy?: MavenAttributesVersionPolicyEnum
  /**
   * Validate that all paths are maven artifact or metadata paths
   * @type {string}
   * @memberof MavenAttributes
   */
  layoutPolicy?: MavenAttributesLayoutPolicyEnum
}

/**
 * @export
 * @enum {string}
 */
export enum MavenAttributesVersionPolicyEnum {
  RELEASE = 'RELEASE',
  SNAPSHOT = 'SNAPSHOT',
  MIXED = 'MIXED',
}
/**
 * @export
 * @enum {string}
 */
export enum MavenAttributesLayoutPolicyEnum {
  STRICT = 'STRICT',
  PERMISSIVE = 'PERMISSIVE',
}

/**
 *
 * @export
 * @interface MavenGroupRepositoryApiRequest
 */
export interface MavenGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof MavenGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof MavenGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof MavenGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof MavenGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface MavenHostedRepositoryApiRequest
 */
export interface MavenHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof MavenHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof MavenHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof MavenHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof MavenHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {MavenAttributes}
   * @memberof MavenHostedRepositoryApiRequest
   */
  maven: MavenAttributes
}
/**
 *
 * @export
 * @interface MavenProxyRepositoryApiRequest
 */
export interface MavenProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof MavenProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof MavenProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof MavenProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {MavenAttributes}
   * @memberof MavenProxyRepositoryApiRequest
   */
  maven: MavenAttributes
}
/**
 *
 * @export
 * @interface NegativeCacheAttributes
 */
export interface NegativeCacheAttributes {
  /**
   * Whether to cache responses for content not present in the proxied repository
   * @type {boolean}
   * @memberof NegativeCacheAttributes
   */
  enabled: boolean
  /**
   * How long to cache the fact that a file was not found in the repository (in minutes)
   * @type {number}
   * @memberof NegativeCacheAttributes
   */
  timeToLive: number
}
/**
 *
 * @export
 * @interface NpmGroupRepositoryApiRequest
 */
export interface NpmGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NpmGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NpmGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof NpmGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof NpmGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface NpmHostedRepositoryApiRequest
 */
export interface NpmHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NpmHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NpmHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof NpmHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof NpmHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface NpmProxyRepositoryApiRequest
 */
export interface NpmProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NpmProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NpmProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof NpmProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof NpmProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof NpmProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof NpmProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof NpmProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof NpmProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface NugetAttributes
 */
export interface NugetAttributes {
  /**
   * How long to cache query results from the proxied repository (in seconds)
   * @type {number}
   * @memberof NugetAttributes
   */
  queryCacheItemMaxAge?: number
}
/**
 *
 * @export
 * @interface NugetGroupRepositoryApiRequest
 */
export interface NugetGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NugetGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NugetGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof NugetGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof NugetGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface NugetHostedRepositoryApiRequest
 */
export interface NugetHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NugetHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NugetHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof NugetHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof NugetHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface NugetProxyRepositoryApiRequest
 */
export interface NugetProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof NugetProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof NugetProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof NugetProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {NugetAttributes}
   * @memberof NugetProxyRepositoryApiRequest
   */
  nugetProxy: NugetAttributes
}
/**
 *
 * @export
 * @interface P2ProxyRepositoryApiRequest
 */
export interface P2ProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof P2ProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof P2ProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof P2ProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof P2ProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof P2ProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof P2ProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof P2ProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof P2ProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface Page
 */
export interface Page {
  /**
   *
   * @type {Array<object>}
   * @memberof Page
   */
  items?: Array<object>
  /**
   *
   * @type {string}
   * @memberof Page
   */
  continuationToken?: string
}
/**
 *
 * @export
 * @interface PageAssetXO
 */
export interface PageAssetXO {
  /**
   *
   * @type {Array<AssetXO>}
   * @memberof PageAssetXO
   */
  items?: Array<AssetXO>
  /**
   *
   * @type {string}
   * @memberof PageAssetXO
   */
  continuationToken?: string
}
/**
 *
 * @export
 * @interface PageComponentXO
 */
export interface PageComponentXO {
  /**
   *
   * @type {Array<ComponentXO>}
   * @memberof PageComponentXO
   */
  items?: Array<ComponentXO>
  /**
   *
   * @type {string}
   * @memberof PageComponentXO
   */
  continuationToken?: string
}
/**
 *
 * @export
 * @interface PageTaskXO
 */
export interface PageTaskXO {
  /**
   *
   * @type {Array<TaskXO>}
   * @memberof PageTaskXO
   */
  items?: Array<TaskXO>
  /**
   *
   * @type {string}
   * @memberof PageTaskXO
   */
  continuationToken?: string
}
/**
 *
 * @export
 * @interface ProxyAttributes
 */
export interface ProxyAttributes {
  /**
   * Location of the remote repository being proxied
   * @type {string}
   * @memberof ProxyAttributes
   */
  remoteUrl?: string
  /**
   * How long to cache artifacts before rechecking the remote repository (in minutes)
   * @type {number}
   * @memberof ProxyAttributes
   */
  contentMaxAge: number
  /**
   * How long to cache metadata before rechecking the remote repository (in minutes)
   * @type {number}
   * @memberof ProxyAttributes
   */
  metadataMaxAge: number
}
/**
 *
 * @export
 * @interface PypiGroupRepositoryApiRequest
 */
export interface PypiGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof PypiGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof PypiGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof PypiGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof PypiGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface PypiHostedRepositoryApiRequest
 */
export interface PypiHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof PypiHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof PypiHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof PypiHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof PypiHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface PypiProxyRepositoryApiRequest
 */
export interface PypiProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof PypiProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof PypiProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof PypiProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof PypiProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof PypiProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof PypiProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof PypiProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof PypiProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface RGroupRepositoryApiRequest
 */
export interface RGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof RGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface RHostedRepositoryApiRequest
 */
export interface RHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof RHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface RProxyRepositoryApiRequest
 */
export interface RProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof RProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof RProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof RProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof RProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface RawAttributes
 */
export interface RawAttributes {
  /**
   * Content Disposition
   * @type {string}
   * @memberof RawAttributes
   */
  contentDisposition?: RawAttributesContentDispositionEnum
}

/**
 * @export
 * @enum {string}
 */
export enum RawAttributesContentDispositionEnum {
  INLINE = 'INLINE',
  ATTACHMENT = 'ATTACHMENT',
}

/**
 *
 * @export
 * @interface RawGroupRepositoryApiRequest
 */
export interface RawGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RawGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RawGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RawGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof RawGroupRepositoryApiRequest
   */
  group: GroupAttributes
  /**
   *
   * @type {RawAttributes}
   * @memberof RawGroupRepositoryApiRequest
   */
  raw?: RawAttributes
}
/**
 *
 * @export
 * @interface RawHostedRepositoryApiRequest
 */
export interface RawHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RawHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RawHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof RawHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RawHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {RawAttributes}
   * @memberof RawHostedRepositoryApiRequest
   */
  raw?: RawAttributes
}
/**
 *
 * @export
 * @interface RawProxyRepositoryApiRequest
 */
export interface RawProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RawProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RawProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof RawProxyRepositoryApiRequest
   */
  routingRule?: string
  /**
   *
   * @type {RawAttributes}
   * @memberof RawProxyRepositoryApiRequest
   */
  raw?: RawAttributes
}
/**
 *
 * @export
 * @interface ReadLdapServerXo
 */
export interface ReadLdapServerXo {
  /**
   * LDAP server name
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  name: string
  /**
   * LDAP server connection Protocol to use
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  protocol: ReadLdapServerXoProtocolEnum
  /**
   * Whether to use certificates stored in Nexus Repository Manager\'s truststore
   * @type {boolean}
   * @memberof ReadLdapServerXo
   */
  useTrustStore?: boolean
  /**
   * LDAP server connection hostname
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  host: string
  /**
   * LDAP server connection port to use
   * @type {number}
   * @memberof ReadLdapServerXo
   */
  port: number
  /**
   * LDAP location to be added to the connection URL
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  searchBase: string
  /**
   * Authentication scheme used for connecting to LDAP server
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  authScheme: ReadLdapServerXoAuthSchemeEnum
  /**
   * The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  authRealm?: string
  /**
   * This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  authUsername?: string
  /**
   * How long to wait before timeout
   * @type {number}
   * @memberof ReadLdapServerXo
   */
  connectionTimeoutSeconds: number
  /**
   * How long to wait before retrying
   * @type {number}
   * @memberof ReadLdapServerXo
   */
  connectionRetryDelaySeconds: number
  /**
   * How many retry attempts
   * @type {number}
   * @memberof ReadLdapServerXo
   */
  maxIncidentsCount: number
  /**
   * The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userBaseDn?: string
  /**
   * Are users located in structures below the user base DN?
   * @type {boolean}
   * @memberof ReadLdapServerXo
   */
  userSubtree?: boolean
  /**
   * LDAP class for user objects
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userObjectClass?: string
  /**
   * LDAP search filter to limit user search
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userLdapFilter?: string
  /**
   * This is used to find a user given its user ID
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userIdAttribute?: string
  /**
   * This is used to find a real name given the user ID
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userRealNameAttribute?: string
  /**
   * This is used to find an email address given the user ID
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userEmailAddressAttribute?: string
  /**
   * If this field is blank the user will be authenticated against a bind with the LDAP server
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userPasswordAttribute?: string
  /**
   * Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
   * @type {boolean}
   * @memberof ReadLdapServerXo
   */
  ldapGroupsAsRoles?: boolean
  /**
   * Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupType: ReadLdapServerXoGroupTypeEnum
  /**
   * The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupBaseDn?: string
  /**
   * Are groups located in structures below the group base DN
   * @type {boolean}
   * @memberof ReadLdapServerXo
   */
  groupSubtree?: boolean
  /**
   * LDAP class for group objects. Required if groupType is static
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupObjectClass?: string
  /**
   * This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupIdAttribute?: string
  /**
   * LDAP attribute containing the usernames for the group. Required if groupType is static
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupMemberAttribute?: string
  /**
   * The format of user ID stored in the group member attribute. Required if groupType is static
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  groupMemberFormat?: string
  /**
   * Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  userMemberOfAttribute?: string
  /**
   * LDAP server ID
   * @type {string}
   * @memberof ReadLdapServerXo
   */
  id?: string
  /**
   * Order number in which the server is being used when looking for a user
   * @type {number}
   * @memberof ReadLdapServerXo
   */
  order?: number
}

/**
 * @export
 * @enum {string}
 */
export enum ReadLdapServerXoProtocolEnum {
  Ldap = 'ldap',
  Ldaps = 'ldaps',
}
/**
 * @export
 * @enum {string}
 */
export enum ReadLdapServerXoAuthSchemeEnum {
  NONE = 'NONE',
  SIMPLE = 'SIMPLE',
  DIGESTMD5 = 'DIGEST_MD5',
  CRAMMD5 = 'CRAM_MD5',
}
/**
 * @export
 * @enum {string}
 */
export enum ReadLdapServerXoGroupTypeEnum {
  Static = 'static',
  Dynamic = 'dynamic',
}

/**
 *
 * @export
 * @interface ReadOnlyState
 */
export interface ReadOnlyState {
  /**
   *
   * @type {boolean}
   * @memberof ReadOnlyState
   */
  systemInitiated?: boolean
  /**
   *
   * @type {string}
   * @memberof ReadOnlyState
   */
  summaryReason?: string
  /**
   *
   * @type {boolean}
   * @memberof ReadOnlyState
   */
  frozen?: boolean
}
/**
 *
 * @export
 * @interface RealmApiXO
 */
export interface RealmApiXO {
  /**
   *
   * @type {string}
   * @memberof RealmApiXO
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof RealmApiXO
   */
  name?: string
}
/**
 *
 * @export
 * @interface RepositoryXO
 */
export interface RepositoryXO {
  /**
   *
   * @type {string}
   * @memberof RepositoryXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RepositoryXO
   */
  format?: string
  /**
   *
   * @type {string}
   * @memberof RepositoryXO
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof RepositoryXO
   */
  url?: string
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof RepositoryXO
   */
  attributes?: { [key: string]: object }
}
/**
 *
 * @export
 * @interface Request
 */
export interface Request {
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  systemInformation?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  threadDump?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  metrics?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  configuration?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  security?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  log?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  taskLog?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  auditLog?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  jmx?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  limitFileSizes?: boolean
  /**
   *
   * @type {boolean}
   * @memberof Request
   */
  limitZipSize?: boolean
}
/**
 *
 * @export
 * @interface Result
 */
export interface Result {
  /**
   *
   * @type {boolean}
   * @memberof Result
   */
  healthy?: boolean
  /**
   *
   * @type {string}
   * @memberof Result
   */
  message?: string
  /**
   *
   * @type {Throwable}
   * @memberof Result
   */
  error?: Throwable
  /**
   *
   * @type {{ [key: string]: object; }}
   * @memberof Result
   */
  details?: { [key: string]: object }
  /**
   *
   * @type {number}
   * @memberof Result
   */
  time?: number
  /**
   *
   * @type {number}
   * @memberof Result
   */
  duration?: number
  /**
   *
   * @type {string}
   * @memberof Result
   */
  timestamp?: string
}
/**
 *
 * @export
 * @interface RoleXORequest
 */
export interface RoleXORequest {
  /**
   * The id of the role.
   * @type {string}
   * @memberof RoleXORequest
   */
  id?: string
  /**
   * The name of the role.
   * @type {string}
   * @memberof RoleXORequest
   */
  name?: string
  /**
   * The description of this role.
   * @type {string}
   * @memberof RoleXORequest
   */
  description?: string
  /**
   * The list of privileges assigned to this role.
   * @type {Array<string>}
   * @memberof RoleXORequest
   */
  privileges?: Array<string>
  /**
   * The list of roles assigned to this role.
   * @type {Array<string>}
   * @memberof RoleXORequest
   */
  roles?: Array<string>
}
/**
 *
 * @export
 * @interface RoleXOResponse
 */
export interface RoleXOResponse {
  /**
   * The id of the role.
   * @type {string}
   * @memberof RoleXOResponse
   */
  id?: string
  /**
   * The user source which is the origin of this role.
   * @type {string}
   * @memberof RoleXOResponse
   */
  source?: string
  /**
   * The name of the role.
   * @type {string}
   * @memberof RoleXOResponse
   */
  name?: string
  /**
   * The description of this role.
   * @type {string}
   * @memberof RoleXOResponse
   */
  description?: string
  /**
   * The list of privileges assigned to this role.
   * @type {Array<string>}
   * @memberof RoleXOResponse
   */
  privileges?: Array<string>
  /**
   * The list of roles assigned to this role.
   * @type {Array<string>}
   * @memberof RoleXOResponse
   */
  roles?: Array<string>
}
/**
 *
 * @export
 * @interface RoutingRuleXO
 */
export interface RoutingRuleXO {
  /**
   *
   * @type {string}
   * @memberof RoutingRuleXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof RoutingRuleXO
   */
  description?: string
  /**
   * Determines what should be done with requests when their path matches any of the matchers
   * @type {string}
   * @memberof RoutingRuleXO
   */
  mode?: RoutingRuleXOModeEnum
  /**
   * Regular expressions used to identify request paths that are allowed or blocked (depending on mode)
   * @type {Array<string>}
   * @memberof RoutingRuleXO
   */
  matchers?: Array<string>
}

/**
 * @export
 * @enum {string}
 */
export enum RoutingRuleXOModeEnum {
  BLOCK = 'BLOCK',
  ALLOW = 'ALLOW',
}

/**
 *
 * @export
 * @interface RubyGemsGroupRepositoryApiRequest
 */
export interface RubyGemsGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RubyGemsGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RubyGemsGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RubyGemsGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof RubyGemsGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface RubyGemsHostedRepositoryApiRequest
 */
export interface RubyGemsHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RubyGemsHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RubyGemsHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof RubyGemsHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RubyGemsHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
}
/**
 *
 * @export
 * @interface RubyGemsProxyRepositoryApiRequest
 */
export interface RubyGemsProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof RubyGemsProxyRepositoryApiRequest
   */
  routingRule?: string
}
/**
 *
 * @export
 * @interface S3BlobStoreApiAdvancedBucketConnection
 */
export interface S3BlobStoreApiAdvancedBucketConnection {
  /**
   * A custom endpoint URL for third party object stores using the S3 API.
   * @type {string}
   * @memberof S3BlobStoreApiAdvancedBucketConnection
   */
  endpoint?: string
  /**
   * An API signature version which may be required for third party object stores using the S3 API.
   * @type {string}
   * @memberof S3BlobStoreApiAdvancedBucketConnection
   */
  signerType?: string
  /**
   * Setting this flag will result in path-style access being used for all requests.
   * @type {boolean}
   * @memberof S3BlobStoreApiAdvancedBucketConnection
   */
  forcePathStyle?: boolean
}
/**
 *
 * @export
 * @interface S3BlobStoreApiBucket
 */
export interface S3BlobStoreApiBucket {
  /**
   * The AWS region to create a new S3 bucket in or an existing S3 bucket\'s region
   * @type {string}
   * @memberof S3BlobStoreApiBucket
   */
  region: string
  /**
   * The name of the S3 bucket
   * @type {string}
   * @memberof S3BlobStoreApiBucket
   */
  name: string
  /**
   * The S3 blob store (i.e S3 object) key prefix
   * @type {string}
   * @memberof S3BlobStoreApiBucket
   */
  prefix?: string
  /**
   * How many days until deleted blobs are finally removed from the S3 bucket (-1 to disable)
   * @type {number}
   * @memberof S3BlobStoreApiBucket
   */
  expiration: number
}
/**
 *
 * @export
 * @interface S3BlobStoreApiBucketConfiguration
 */
export interface S3BlobStoreApiBucketConfiguration {
  /**
   *
   * @type {S3BlobStoreApiBucket}
   * @memberof S3BlobStoreApiBucketConfiguration
   */
  bucket: S3BlobStoreApiBucket
  /**
   *
   * @type {S3BlobStoreApiEncryption}
   * @memberof S3BlobStoreApiBucketConfiguration
   */
  encryption?: S3BlobStoreApiEncryption
  /**
   *
   * @type {S3BlobStoreApiBucketSecurity}
   * @memberof S3BlobStoreApiBucketConfiguration
   */
  bucketSecurity?: S3BlobStoreApiBucketSecurity
  /**
   *
   * @type {S3BlobStoreApiAdvancedBucketConnection}
   * @memberof S3BlobStoreApiBucketConfiguration
   */
  advancedBucketConnection?: S3BlobStoreApiAdvancedBucketConnection
}
/**
 *
 * @export
 * @interface S3BlobStoreApiBucketSecurity
 */
export interface S3BlobStoreApiBucketSecurity {
  /**
   * An IAM access key ID for granting access to the S3 bucket
   * @type {string}
   * @memberof S3BlobStoreApiBucketSecurity
   */
  accessKeyId?: string
  /**
   * The secret access key associated with the specified IAM access key ID
   * @type {string}
   * @memberof S3BlobStoreApiBucketSecurity
   */
  secretAccessKey?: string
  /**
   * An IAM role to assume in order to access the S3 bucket
   * @type {string}
   * @memberof S3BlobStoreApiBucketSecurity
   */
  role?: string
  /**
   * An AWS STS session token associated with temporary security credentials which grant access to the S3 bucket
   * @type {string}
   * @memberof S3BlobStoreApiBucketSecurity
   */
  sessionToken?: string
}
/**
 *
 * @export
 * @interface S3BlobStoreApiEncryption
 */
export interface S3BlobStoreApiEncryption {
  /**
   * The type of S3 server side encryption to use.
   * @type {string}
   * @memberof S3BlobStoreApiEncryption
   */
  encryptionType?: S3BlobStoreApiEncryptionEncryptionTypeEnum
  /**
   * The encryption key.
   * @type {string}
   * @memberof S3BlobStoreApiEncryption
   */
  encryptionKey?: string
}

/**
 * @export
 * @enum {string}
 */
export enum S3BlobStoreApiEncryptionEncryptionTypeEnum {
  S3ManagedEncryption = 's3ManagedEncryption',
  KmsManagedEncryption = 'kmsManagedEncryption',
}

/**
 *
 * @export
 * @interface S3BlobStoreApiModel
 */
export interface S3BlobStoreApiModel {
  /**
   * The name of the S3 blob store.
   * @type {string}
   * @memberof S3BlobStoreApiModel
   */
  name: string
  /**
   *
   * @type {BlobStoreApiSoftQuota}
   * @memberof S3BlobStoreApiModel
   */
  softQuota?: BlobStoreApiSoftQuota
  /**
   *
   * @type {S3BlobStoreApiBucketConfiguration}
   * @memberof S3BlobStoreApiModel
   */
  bucketConfiguration: S3BlobStoreApiBucketConfiguration
}
/**
 *
 * @export
 * @interface ScriptResultXO
 */
export interface ScriptResultXO {
  /**
   *
   * @type {string}
   * @memberof ScriptResultXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ScriptResultXO
   */
  result?: string
}
/**
 *
 * @export
 * @interface ScriptXO
 */
export interface ScriptXO {
  /**
   *
   * @type {string}
   * @memberof ScriptXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof ScriptXO
   */
  content?: string
  /**
   *
   * @type {string}
   * @memberof ScriptXO
   */
  type?: string
}
/**
 *
 * @export
 * @interface StackTraceElement
 */
export interface StackTraceElement {
  /**
   *
   * @type {string}
   * @memberof StackTraceElement
   */
  methodName?: string
  /**
   *
   * @type {string}
   * @memberof StackTraceElement
   */
  fileName?: string
  /**
   *
   * @type {number}
   * @memberof StackTraceElement
   */
  lineNumber?: number
  /**
   *
   * @type {string}
   * @memberof StackTraceElement
   */
  className?: string
  /**
   *
   * @type {boolean}
   * @memberof StackTraceElement
   */
  nativeMethod?: boolean
}
/**
 *
 * @export
 * @interface StorageAttributes
 */
export interface StorageAttributes {
  /**
   * Blob store used to store repository contents
   * @type {string}
   * @memberof StorageAttributes
   */
  blobStoreName?: string
  /**
   * Whether to validate uploaded content\'s MIME type appropriate for the repository format
   * @type {boolean}
   * @memberof StorageAttributes
   */
  strictContentTypeValidation: boolean
}
/**
 *
 * @export
 * @interface SupportZipXO
 */
export interface SupportZipXO {
  /**
   *
   * @type {string}
   * @memberof SupportZipXO
   */
  file?: string
  /**
   *
   * @type {string}
   * @memberof SupportZipXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof SupportZipXO
   */
  size?: string
  /**
   *
   * @type {boolean}
   * @memberof SupportZipXO
   */
  truncated?: boolean
}
/**
 *
 * @export
 * @interface TaskXO
 */
export interface TaskXO {
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  id?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  currentState?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  lastRunResult?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  nextRun?: string
  /**
   *
   * @type {string}
   * @memberof TaskXO
   */
  lastRun?: string
}
/**
 *
 * @export
 * @interface Throwable
 */
export interface Throwable {
  /**
   *
   * @type {Throwable}
   * @memberof Throwable
   */
  cause?: Throwable
  /**
   *
   * @type {Array<StackTraceElement>}
   * @memberof Throwable
   */
  stackTrace?: Array<StackTraceElement>
  /**
   *
   * @type {string}
   * @memberof Throwable
   */
  message?: string
  /**
   *
   * @type {string}
   * @memberof Throwable
   */
  localizedMessage?: string
  /**
   *
   * @type {Array<Throwable>}
   * @memberof Throwable
   */
  suppressed?: Array<Throwable>
}
/**
 *
 * @export
 * @interface UpdateLdapServerXo
 */
export interface UpdateLdapServerXo {
  /**
   * LDAP server name
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  name: string
  /**
   * LDAP server connection Protocol to use
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  protocol: UpdateLdapServerXoProtocolEnum
  /**
   * Whether to use certificates stored in Nexus Repository Manager\'s truststore
   * @type {boolean}
   * @memberof UpdateLdapServerXo
   */
  useTrustStore?: boolean
  /**
   * LDAP server connection hostname
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  host: string
  /**
   * LDAP server connection port to use
   * @type {number}
   * @memberof UpdateLdapServerXo
   */
  port: number
  /**
   * LDAP location to be added to the connection URL
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  searchBase: string
  /**
   * Authentication scheme used for connecting to LDAP server
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  authScheme: UpdateLdapServerXoAuthSchemeEnum
  /**
   * The SASL realm to bind to. Required if authScheme is CRAM_MD5 or DIGEST_MD5
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  authRealm?: string
  /**
   * This must be a fully qualified username if simple authentication is used. Required if authScheme other than none.
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  authUsername?: string
  /**
   * How long to wait before timeout
   * @type {number}
   * @memberof UpdateLdapServerXo
   */
  connectionTimeoutSeconds: number
  /**
   * How long to wait before retrying
   * @type {number}
   * @memberof UpdateLdapServerXo
   */
  connectionRetryDelaySeconds: number
  /**
   * How many retry attempts
   * @type {number}
   * @memberof UpdateLdapServerXo
   */
  maxIncidentsCount: number
  /**
   * The relative DN where user objects are found (e.g. ou=people). This value will have the Search base DN value appended to form the full User search base DN.
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userBaseDn?: string
  /**
   * Are users located in structures below the user base DN?
   * @type {boolean}
   * @memberof UpdateLdapServerXo
   */
  userSubtree?: boolean
  /**
   * LDAP class for user objects
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userObjectClass?: string
  /**
   * LDAP search filter to limit user search
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userLdapFilter?: string
  /**
   * This is used to find a user given its user ID
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userIdAttribute?: string
  /**
   * This is used to find a real name given the user ID
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userRealNameAttribute?: string
  /**
   * This is used to find an email address given the user ID
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userEmailAddressAttribute?: string
  /**
   * If this field is blank the user will be authenticated against a bind with the LDAP server
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userPasswordAttribute?: string
  /**
   * Denotes whether LDAP assigned roles are used as Nexus Repository Manager roles
   * @type {boolean}
   * @memberof UpdateLdapServerXo
   */
  ldapGroupsAsRoles?: boolean
  /**
   * Defines a type of groups used: static (a group contains a list of users) or dynamic (a user contains a list of groups). Required if ldapGroupsAsRoles is true.
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupType: UpdateLdapServerXoGroupTypeEnum
  /**
   * The relative DN where group objects are found (e.g. ou=Group). This value will have the Search base DN value appended to form the full Group search base DN.
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupBaseDn?: string
  /**
   * Are groups located in structures below the group base DN
   * @type {boolean}
   * @memberof UpdateLdapServerXo
   */
  groupSubtree?: boolean
  /**
   * LDAP class for group objects. Required if groupType is static
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupObjectClass?: string
  /**
   * This field specifies the attribute of the Object class that defines the Group ID. Required if groupType is static
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupIdAttribute?: string
  /**
   * LDAP attribute containing the usernames for the group. Required if groupType is static
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupMemberAttribute?: string
  /**
   * The format of user ID stored in the group member attribute. Required if groupType is static
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  groupMemberFormat?: string
  /**
   * Set this to the attribute used to store the attribute which holds groups DN in the user object. Required if groupType is dynamic
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  userMemberOfAttribute?: string
  /**
   * The password to bind with. Required if authScheme other than none.
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  authPassword: string
  /**
   * LDAP server ID
   * @type {string}
   * @memberof UpdateLdapServerXo
   */
  id?: string
}

/**
 * @export
 * @enum {string}
 */
export enum UpdateLdapServerXoProtocolEnum {
  Ldap = 'ldap',
  Ldaps = 'ldaps',
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateLdapServerXoAuthSchemeEnum {
  NONE = 'NONE',
  SIMPLE = 'SIMPLE',
  DIGESTMD5 = 'DIGEST_MD5',
  CRAMMD5 = 'CRAM_MD5',
}
/**
 * @export
 * @enum {string}
 */
export enum UpdateLdapServerXoGroupTypeEnum {
  Static = 'static',
  Dynamic = 'dynamic',
}

/**
 *
 * @export
 * @interface UploadDefinitionXO
 */
export interface UploadDefinitionXO {
  /**
   *
   * @type {string}
   * @memberof UploadDefinitionXO
   */
  format?: string
  /**
   *
   * @type {boolean}
   * @memberof UploadDefinitionXO
   */
  multipleUpload?: boolean
  /**
   *
   * @type {Array<UploadFieldDefinitionXO>}
   * @memberof UploadDefinitionXO
   */
  componentFields?: Array<UploadFieldDefinitionXO>
  /**
   *
   * @type {Array<UploadFieldDefinitionXO>}
   * @memberof UploadDefinitionXO
   */
  assetFields?: Array<UploadFieldDefinitionXO>
}
/**
 *
 * @export
 * @interface UploadFieldDefinitionXO
 */
export interface UploadFieldDefinitionXO {
  /**
   *
   * @type {string}
   * @memberof UploadFieldDefinitionXO
   */
  name?: string
  /**
   *
   * @type {string}
   * @memberof UploadFieldDefinitionXO
   */
  type?: string
  /**
   *
   * @type {string}
   * @memberof UploadFieldDefinitionXO
   */
  description?: string
  /**
   *
   * @type {boolean}
   * @memberof UploadFieldDefinitionXO
   */
  optional?: boolean
  /**
   *
   * @type {string}
   * @memberof UploadFieldDefinitionXO
   */
  group?: string
}
/**
 *
 * @export
 * @interface YumAttributes
 */
export interface YumAttributes {
  /**
   * Specifies the repository depth where repodata folder(s) are created
   * @type {number}
   * @memberof YumAttributes
   */
  repodataDepth: number
  /**
   * Validate that all paths are RPMs or yum metadata
   * @type {string}
   * @memberof YumAttributes
   */
  deployPolicy?: YumAttributesDeployPolicyEnum
}

/**
 * @export
 * @enum {string}
 */
export enum YumAttributesDeployPolicyEnum {
  PERMISSIVE = 'PERMISSIVE',
  STRICT = 'STRICT',
}

/**
 *
 * @export
 * @interface YumGroupRepositoryApiRequest
 */
export interface YumGroupRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof YumGroupRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof YumGroupRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof YumGroupRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {GroupAttributes}
   * @memberof YumGroupRepositoryApiRequest
   */
  group: GroupAttributes
}
/**
 *
 * @export
 * @interface YumHostedRepositoryApiRequest
 */
export interface YumHostedRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof YumHostedRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof YumHostedRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {HostedStorageAttributes}
   * @memberof YumHostedRepositoryApiRequest
   */
  storage: HostedStorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof YumHostedRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {YumAttributes}
   * @memberof YumHostedRepositoryApiRequest
   */
  yum: YumAttributes
}
/**
 *
 * @export
 * @interface YumProxyRepositoryApiRequest
 */
export interface YumProxyRepositoryApiRequest {
  /**
   * A unique identifier for this repository
   * @type {string}
   * @memberof YumProxyRepositoryApiRequest
   */
  name: string
  /**
   * Whether this repository accepts incoming requests
   * @type {boolean}
   * @memberof YumProxyRepositoryApiRequest
   */
  online: boolean
  /**
   *
   * @type {StorageAttributes}
   * @memberof YumProxyRepositoryApiRequest
   */
  storage: StorageAttributes
  /**
   *
   * @type {CleanupPolicyAttributes}
   * @memberof YumProxyRepositoryApiRequest
   */
  cleanup?: CleanupPolicyAttributes
  /**
   *
   * @type {ProxyAttributes}
   * @memberof YumProxyRepositoryApiRequest
   */
  proxy: ProxyAttributes
  /**
   *
   * @type {NegativeCacheAttributes}
   * @memberof YumProxyRepositoryApiRequest
   */
  negativeCache: NegativeCacheAttributes
  /**
   *
   * @type {HttpClientAttributes}
   * @memberof YumProxyRepositoryApiRequest
   */
  httpClient: HttpClientAttributes
  /**
   *
   * @type {string}
   * @memberof YumProxyRepositoryApiRequest
   */
  routingRule?: string
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete a single asset
     * @param {string} id Id of the asset to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAsset: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteAsset.',
        )
      }
      const localVarPath = `/v1/assets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a single asset
     * @param {string} id Id of the asset to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetById: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getAssetById.',
        )
      }
      const localVarPath = `/v1/assets/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List assets
     * @param {string} repository Repository from which you would like to retrieve assets.
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssets: async (
      repository: string,
      continuationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repository' is not null or undefined
      if (repository === null || repository === undefined) {
        throw new RequiredError(
          'repository',
          'Required parameter repository was null or undefined when calling getAssets.',
        )
      }
      const localVarPath = `/v1/assets`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (continuationToken !== undefined) {
        localVarQueryParameter['continuationToken'] = continuationToken
      }

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a single asset
     * @param {string} id Id of the asset to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteAsset(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await AssetsApiAxiosParamCreator(
        configuration,
      ).deleteAsset(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get a single asset
     * @param {string} id Id of the asset to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssetById(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AssetXO>
    > {
      const localVarAxiosArgs = await AssetsApiAxiosParamCreator(
        configuration,
      ).getAssetById(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List assets
     * @param {string} repository Repository from which you would like to retrieve assets.
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getAssets(
      repository: string,
      continuationToken?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAssetXO>
    > {
      const localVarAxiosArgs = await AssetsApiAxiosParamCreator(
        configuration,
      ).getAssets(repository, continuationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Delete a single asset
     * @param {string} id Id of the asset to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteAsset(id: string, options?: any): AxiosPromise<void> {
      return AssetsApiFp(configuration)
        .deleteAsset(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a single asset
     * @param {string} id Id of the asset to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssetById(id: string, options?: any): AxiosPromise<AssetXO> {
      return AssetsApiFp(configuration)
        .getAssetById(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List assets
     * @param {string} repository Repository from which you would like to retrieve assets.
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAssets(
      repository: string,
      continuationToken?: string,
      options?: any,
    ): AxiosPromise<PageAssetXO> {
      return AssetsApiFp(configuration)
        .getAssets(repository, continuationToken, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
  /**
   *
   * @summary Delete a single asset
   * @param {string} id Id of the asset to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public deleteAsset(id: string, options?: any) {
    return AssetsApiFp(this.configuration)
      .deleteAsset(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a single asset
   * @param {string} id Id of the asset to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAssetById(id: string, options?: any) {
    return AssetsApiFp(this.configuration)
      .getAssetById(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List assets
   * @param {string} repository Repository from which you would like to retrieve assets.
   * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AssetsApi
   */
  public getAssets(
    repository: string,
    continuationToken?: string,
    options?: any,
  ) {
    return AssetsApiFp(this.configuration)
      .getAssets(repository, continuationToken, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * BlobStoreApi - axios parameter creator
 * @export
 */
export const BlobStoreApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create an S3 blob store
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBlobStore: async (
      body?: S3BlobStoreApiModel,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/blobstores/s3`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a file blob store
     * @param {FileBlobStoreApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileBlobStore: async (
      body?: FileBlobStoreApiCreateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/blobstores/file`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a blob store by name
     * @param {string} name The name of the blob store to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBlobStore: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteBlobStore.',
        )
      }
      const localVarPath = `/v1/blobstores/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Fetch a S3 blob store configuration
     * @param {string} name Name of the blob store configuration to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlobStore: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getBlobStore.',
        )
      }
      const localVarPath = `/v1/blobstores/s3/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a file blob store configuration by name
     * @param {string} name The name of the file blob store to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileBlobStoreConfiguration: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getFileBlobStoreConfiguration.',
        )
      }
      const localVarPath = `/v1/blobstores/file/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List the blob stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlobStores: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/blobstores`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get quota status for a given blob store
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotaStatus: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling quotaStatus.',
        )
      }
      const localVarPath = `/v1/blobstores/{name}/quota-status`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update an S3 blob store configuration
     * @param {string} name Name of the blob store to update
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBlobStore: async (
      name: string,
      body?: S3BlobStoreApiModel,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updateBlobStore.',
        )
      }
      const localVarPath = `/v1/blobstores/s3/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a file blob store configuration by name
     * @param {string} name The name of the file blob store to update
     * @param {FileBlobStoreApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileBlobStore: async (
      name: string,
      body?: FileBlobStoreApiUpdateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updateFileBlobStore.',
        )
      }
      const localVarPath = `/v1/blobstores/file/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * BlobStoreApi - functional programming interface
 * @export
 */
export const BlobStoreApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create an S3 blob store
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createBlobStore(
      body?: S3BlobStoreApiModel,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).createBlobStore(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a file blob store
     * @param {FileBlobStoreApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createFileBlobStore(
      body?: FileBlobStoreApiCreateRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).createFileBlobStore(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete a blob store by name
     * @param {string} name The name of the blob store to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteBlobStore(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).deleteBlobStore(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Fetch a S3 blob store configuration
     * @param {string} name Name of the blob store configuration to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBlobStore(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).getBlobStore(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get a file blob store configuration by name
     * @param {string} name The name of the file blob store to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getFileBlobStoreConfiguration(
      name: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<FileBlobStoreApiModel>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).getFileBlobStoreConfiguration(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List the blob stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listBlobStores(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<GenericBlobStoreApiResponse>>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).listBlobStores(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get quota status for a given blob store
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async quotaStatus(
      name: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<BlobStoreQuotaResultXO>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).quotaStatus(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update an S3 blob store configuration
     * @param {string} name Name of the blob store to update
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateBlobStore(
      name: string,
      body?: S3BlobStoreApiModel,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).updateBlobStore(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a file blob store configuration by name
     * @param {string} name The name of the file blob store to update
     * @param {FileBlobStoreApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateFileBlobStore(
      name: string,
      body?: FileBlobStoreApiUpdateRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await BlobStoreApiAxiosParamCreator(
        configuration,
      ).updateFileBlobStore(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * BlobStoreApi - factory interface
 * @export
 */
export const BlobStoreApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Create an S3 blob store
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createBlobStore(
      body?: S3BlobStoreApiModel,
      options?: any,
    ): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .createBlobStore(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a file blob store
     * @param {FileBlobStoreApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createFileBlobStore(
      body?: FileBlobStoreApiCreateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .createFileBlobStore(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a blob store by name
     * @param {string} name The name of the blob store to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteBlobStore(name: string, options?: any): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .deleteBlobStore(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Fetch a S3 blob store configuration
     * @param {string} name Name of the blob store configuration to fetch
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBlobStore(name: string, options?: any): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .getBlobStore(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a file blob store configuration by name
     * @param {string} name The name of the file blob store to read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getFileBlobStoreConfiguration(
      name: string,
      options?: any,
    ): AxiosPromise<FileBlobStoreApiModel> {
      return BlobStoreApiFp(configuration)
        .getFileBlobStoreConfiguration(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List the blob stores
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listBlobStores(
      options?: any,
    ): AxiosPromise<Array<GenericBlobStoreApiResponse>> {
      return BlobStoreApiFp(configuration)
        .listBlobStores(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get quota status for a given blob store
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    quotaStatus(
      name: string,
      options?: any,
    ): AxiosPromise<BlobStoreQuotaResultXO> {
      return BlobStoreApiFp(configuration)
        .quotaStatus(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update an S3 blob store configuration
     * @param {string} name Name of the blob store to update
     * @param {S3BlobStoreApiModel} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateBlobStore(
      name: string,
      body?: S3BlobStoreApiModel,
      options?: any,
    ): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .updateBlobStore(name, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a file blob store configuration by name
     * @param {string} name The name of the file blob store to update
     * @param {FileBlobStoreApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateFileBlobStore(
      name: string,
      body?: FileBlobStoreApiUpdateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return BlobStoreApiFp(configuration)
        .updateFileBlobStore(name, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * BlobStoreApi - object-oriented interface
 * @export
 * @class BlobStoreApi
 * @extends {BaseAPI}
 */
export class BlobStoreApi extends BaseAPI {
  /**
   *
   * @summary Create an S3 blob store
   * @param {S3BlobStoreApiModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public createBlobStore(body?: S3BlobStoreApiModel, options?: any) {
    return BlobStoreApiFp(this.configuration)
      .createBlobStore(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a file blob store
   * @param {FileBlobStoreApiCreateRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public createFileBlobStore(
    body?: FileBlobStoreApiCreateRequest,
    options?: any,
  ) {
    return BlobStoreApiFp(this.configuration)
      .createFileBlobStore(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a blob store by name
   * @param {string} name The name of the blob store to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public deleteBlobStore(name: string, options?: any) {
    return BlobStoreApiFp(this.configuration)
      .deleteBlobStore(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Fetch a S3 blob store configuration
   * @param {string} name Name of the blob store configuration to fetch
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public getBlobStore(name: string, options?: any) {
    return BlobStoreApiFp(this.configuration)
      .getBlobStore(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a file blob store configuration by name
   * @param {string} name The name of the file blob store to read
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public getFileBlobStoreConfiguration(name: string, options?: any) {
    return BlobStoreApiFp(this.configuration)
      .getFileBlobStoreConfiguration(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List the blob stores
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public listBlobStores(options?: any) {
    return BlobStoreApiFp(this.configuration)
      .listBlobStores(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get quota status for a given blob store
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public quotaStatus(name: string, options?: any) {
    return BlobStoreApiFp(this.configuration)
      .quotaStatus(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update an S3 blob store configuration
   * @param {string} name Name of the blob store to update
   * @param {S3BlobStoreApiModel} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public updateBlobStore(
    name: string,
    body?: S3BlobStoreApiModel,
    options?: any,
  ) {
    return BlobStoreApiFp(this.configuration)
      .updateBlobStore(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a file blob store configuration by name
   * @param {string} name The name of the file blob store to update
   * @param {FileBlobStoreApiUpdateRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BlobStoreApi
   */
  public updateFileBlobStore(
    name: string,
    body?: FileBlobStoreApiUpdateRequest,
    options?: any,
  ) {
    return BlobStoreApiFp(this.configuration)
      .updateFileBlobStore(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ComponentsApi - axios parameter creator
 * @export
 */
export const ComponentsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete a single component
     * @param {string} id ID of the component to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComponent: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling deleteComponent.',
        )
      }
      const localVarPath = `/v1/components/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a single component
     * @param {string} id ID of the component to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComponentById: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getComponentById.',
        )
      }
      const localVarPath = `/v1/components/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List components
     * @param {string} repository Repository from which you would like to retrieve components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComponents: async (
      repository: string,
      continuationToken?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repository' is not null or undefined
      if (repository === null || repository === undefined) {
        throw new RequiredError(
          'repository',
          'Required parameter repository was null or undefined when calling getComponents.',
        )
      }
      const localVarPath = `/v1/components`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (continuationToken !== undefined) {
        localVarQueryParameter['continuationToken'] = continuationToken
      }

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Upload a single component
     * @param {string} repository Name of the repository to which you would like to upload the component
     * @param {string} [yumDirectory] yum Directory
     * @param {any} [yumAsset] yum Asset
     * @param {string} [yumAssetFilename] yum Asset  Filename
     * @param {any} [dockerAsset] docker Asset
     * @param {any} [rAsset] r Asset
     * @param {string} [rAssetPathId] r Asset  Package Path
     * @param {any} [pypiAsset] pypi Asset
     * @param {any} [aptAsset] apt Asset
     * @param {any} [rubygemsAsset] rubygems Asset
     * @param {any} [npmAsset] npm Asset
     * @param {any} [nugetAsset] nuget Asset
     * @param {any} [helmAsset] helm Asset
     * @param {string} [rawDirectory] raw Directory
     * @param {any} [rawAsset1] raw Asset 1
     * @param {string} [rawAsset1Filename] raw Asset 1 Filename
     * @param {any} [rawAsset2] raw Asset 2
     * @param {string} [rawAsset2Filename] raw Asset 2 Filename
     * @param {any} [rawAsset3] raw Asset 3
     * @param {string} [rawAsset3Filename] raw Asset 3 Filename
     * @param {string} [maven2GroupId] maven2 Group ID
     * @param {string} [maven2ArtifactId] maven2 Artifact ID
     * @param {string} [maven2Version] maven2 Version
     * @param {boolean} [maven2GeneratePom] maven2 Generate a POM file with these coordinates
     * @param {string} [maven2Packaging] maven2 Packaging
     * @param {any} [maven2Asset1] maven2 Asset 1
     * @param {string} [maven2Asset1Classifier] maven2 Asset 1 Classifier
     * @param {string} [maven2Asset1Extension] maven2 Asset 1 Extension
     * @param {any} [maven2Asset2] maven2 Asset 2
     * @param {string} [maven2Asset2Classifier] maven2 Asset 2 Classifier
     * @param {string} [maven2Asset2Extension] maven2 Asset 2 Extension
     * @param {any} [maven2Asset3] maven2 Asset 3
     * @param {string} [maven2Asset3Classifier] maven2 Asset 3 Classifier
     * @param {string} [maven2Asset3Extension] maven2 Asset 3 Extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadComponent: async (
      repository: string,
      yumDirectory?: string,
      yumAsset?: any,
      yumAssetFilename?: string,
      dockerAsset?: any,
      rAsset?: any,
      rAssetPathId?: string,
      pypiAsset?: any,
      aptAsset?: any,
      rubygemsAsset?: any,
      npmAsset?: any,
      nugetAsset?: any,
      helmAsset?: any,
      rawDirectory?: string,
      rawAsset1?: any,
      rawAsset1Filename?: string,
      rawAsset2?: any,
      rawAsset2Filename?: string,
      rawAsset3?: any,
      rawAsset3Filename?: string,
      maven2GroupId?: string,
      maven2ArtifactId?: string,
      maven2Version?: string,
      maven2GeneratePom?: boolean,
      maven2Packaging?: string,
      maven2Asset1?: any,
      maven2Asset1Classifier?: string,
      maven2Asset1Extension?: string,
      maven2Asset2?: any,
      maven2Asset2Classifier?: string,
      maven2Asset2Extension?: string,
      maven2Asset3?: any,
      maven2Asset3Classifier?: string,
      maven2Asset3Extension?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repository' is not null or undefined
      if (repository === null || repository === undefined) {
        throw new RequiredError(
          'repository',
          'Required parameter repository was null or undefined when calling uploadComponent.',
        )
      }
      const localVarPath = `/v1/components`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any
      const localVarFormParams = new FormData()

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      if (yumDirectory !== undefined) {
        localVarFormParams.append('yum.directory', yumDirectory as any)
      }

      if (yumAsset !== undefined) {
        localVarFormParams.append('yum.asset', yumAsset as any)
      }

      if (yumAssetFilename !== undefined) {
        localVarFormParams.append('yum.asset.filename', yumAssetFilename as any)
      }

      if (dockerAsset !== undefined) {
        localVarFormParams.append('docker.asset', dockerAsset as any)
      }

      if (rAsset !== undefined) {
        localVarFormParams.append('r.asset', rAsset as any)
      }

      if (rAssetPathId !== undefined) {
        localVarFormParams.append('r.asset.pathId', rAssetPathId as any)
      }

      if (pypiAsset !== undefined) {
        localVarFormParams.append('pypi.asset', pypiAsset as any)
      }

      if (aptAsset !== undefined) {
        localVarFormParams.append('apt.asset', aptAsset as any)
      }

      if (rubygemsAsset !== undefined) {
        localVarFormParams.append('rubygems.asset', rubygemsAsset as any)
      }

      if (npmAsset !== undefined) {
        localVarFormParams.append('npm.asset', npmAsset as any)
      }

      if (nugetAsset !== undefined) {
        localVarFormParams.append('nuget.asset', nugetAsset as any)
      }

      if (helmAsset !== undefined) {
        localVarFormParams.append('helm.asset', helmAsset as any)
      }

      if (rawDirectory !== undefined) {
        localVarFormParams.append('raw.directory', rawDirectory as any)
      }

      if (rawAsset1 !== undefined) {
        localVarFormParams.append('raw.asset1', rawAsset1 as any)
      }

      if (rawAsset1Filename !== undefined) {
        localVarFormParams.append(
          'raw.asset1.filename',
          rawAsset1Filename as any,
        )
      }

      if (rawAsset2 !== undefined) {
        localVarFormParams.append('raw.asset2', rawAsset2 as any)
      }

      if (rawAsset2Filename !== undefined) {
        localVarFormParams.append(
          'raw.asset2.filename',
          rawAsset2Filename as any,
        )
      }

      if (rawAsset3 !== undefined) {
        localVarFormParams.append('raw.asset3', rawAsset3 as any)
      }

      if (rawAsset3Filename !== undefined) {
        localVarFormParams.append(
          'raw.asset3.filename',
          rawAsset3Filename as any,
        )
      }

      if (maven2GroupId !== undefined) {
        localVarFormParams.append('maven2.groupId', maven2GroupId as any)
      }

      if (maven2ArtifactId !== undefined) {
        localVarFormParams.append('maven2.artifactId', maven2ArtifactId as any)
      }

      if (maven2Version !== undefined) {
        localVarFormParams.append('maven2.version', maven2Version as any)
      }

      if (maven2GeneratePom !== undefined) {
        localVarFormParams.append(
          'maven2.generate-pom',
          maven2GeneratePom as any,
        )
      }

      if (maven2Packaging !== undefined) {
        localVarFormParams.append('maven2.packaging', maven2Packaging as any)
      }

      if (maven2Asset1 !== undefined) {
        localVarFormParams.append('maven2.asset1', maven2Asset1 as any)
      }

      if (maven2Asset1Classifier !== undefined) {
        localVarFormParams.append(
          'maven2.asset1.classifier',
          maven2Asset1Classifier as any,
        )
      }

      if (maven2Asset1Extension !== undefined) {
        localVarFormParams.append(
          'maven2.asset1.extension',
          maven2Asset1Extension as any,
        )
      }

      if (maven2Asset2 !== undefined) {
        localVarFormParams.append('maven2.asset2', maven2Asset2 as any)
      }

      if (maven2Asset2Classifier !== undefined) {
        localVarFormParams.append(
          'maven2.asset2.classifier',
          maven2Asset2Classifier as any,
        )
      }

      if (maven2Asset2Extension !== undefined) {
        localVarFormParams.append(
          'maven2.asset2.extension',
          maven2Asset2Extension as any,
        )
      }

      if (maven2Asset3 !== undefined) {
        localVarFormParams.append('maven2.asset3', maven2Asset3 as any)
      }

      if (maven2Asset3Classifier !== undefined) {
        localVarFormParams.append(
          'maven2.asset3.classifier',
          maven2Asset3Classifier as any,
        )
      }

      if (maven2Asset3Extension !== undefined) {
        localVarFormParams.append(
          'maven2.asset3.extension',
          maven2Asset3Extension as any,
        )
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      localVarRequestOptions.data = localVarFormParams

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ComponentsApi - functional programming interface
 * @export
 */
export const ComponentsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Delete a single component
     * @param {string} id ID of the component to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteComponent(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ComponentsApiAxiosParamCreator(
        configuration,
      ).deleteComponent(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get a single component
     * @param {string} id ID of the component to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComponentById(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ComponentXO>
    > {
      const localVarAxiosArgs = await ComponentsApiAxiosParamCreator(
        configuration,
      ).getComponentById(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List components
     * @param {string} repository Repository from which you would like to retrieve components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getComponents(
      repository: string,
      continuationToken?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PageComponentXO>
    > {
      const localVarAxiosArgs = await ComponentsApiAxiosParamCreator(
        configuration,
      ).getComponents(repository, continuationToken, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Upload a single component
     * @param {string} repository Name of the repository to which you would like to upload the component
     * @param {string} [yumDirectory] yum Directory
     * @param {any} [yumAsset] yum Asset
     * @param {string} [yumAssetFilename] yum Asset  Filename
     * @param {any} [dockerAsset] docker Asset
     * @param {any} [rAsset] r Asset
     * @param {string} [rAssetPathId] r Asset  Package Path
     * @param {any} [pypiAsset] pypi Asset
     * @param {any} [aptAsset] apt Asset
     * @param {any} [rubygemsAsset] rubygems Asset
     * @param {any} [npmAsset] npm Asset
     * @param {any} [nugetAsset] nuget Asset
     * @param {any} [helmAsset] helm Asset
     * @param {string} [rawDirectory] raw Directory
     * @param {any} [rawAsset1] raw Asset 1
     * @param {string} [rawAsset1Filename] raw Asset 1 Filename
     * @param {any} [rawAsset2] raw Asset 2
     * @param {string} [rawAsset2Filename] raw Asset 2 Filename
     * @param {any} [rawAsset3] raw Asset 3
     * @param {string} [rawAsset3Filename] raw Asset 3 Filename
     * @param {string} [maven2GroupId] maven2 Group ID
     * @param {string} [maven2ArtifactId] maven2 Artifact ID
     * @param {string} [maven2Version] maven2 Version
     * @param {boolean} [maven2GeneratePom] maven2 Generate a POM file with these coordinates
     * @param {string} [maven2Packaging] maven2 Packaging
     * @param {any} [maven2Asset1] maven2 Asset 1
     * @param {string} [maven2Asset1Classifier] maven2 Asset 1 Classifier
     * @param {string} [maven2Asset1Extension] maven2 Asset 1 Extension
     * @param {any} [maven2Asset2] maven2 Asset 2
     * @param {string} [maven2Asset2Classifier] maven2 Asset 2 Classifier
     * @param {string} [maven2Asset2Extension] maven2 Asset 2 Extension
     * @param {any} [maven2Asset3] maven2 Asset 3
     * @param {string} [maven2Asset3Classifier] maven2 Asset 3 Classifier
     * @param {string} [maven2Asset3Extension] maven2 Asset 3 Extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async uploadComponent(
      repository: string,
      yumDirectory?: string,
      yumAsset?: any,
      yumAssetFilename?: string,
      dockerAsset?: any,
      rAsset?: any,
      rAssetPathId?: string,
      pypiAsset?: any,
      aptAsset?: any,
      rubygemsAsset?: any,
      npmAsset?: any,
      nugetAsset?: any,
      helmAsset?: any,
      rawDirectory?: string,
      rawAsset1?: any,
      rawAsset1Filename?: string,
      rawAsset2?: any,
      rawAsset2Filename?: string,
      rawAsset3?: any,
      rawAsset3Filename?: string,
      maven2GroupId?: string,
      maven2ArtifactId?: string,
      maven2Version?: string,
      maven2GeneratePom?: boolean,
      maven2Packaging?: string,
      maven2Asset1?: any,
      maven2Asset1Classifier?: string,
      maven2Asset1Extension?: string,
      maven2Asset2?: any,
      maven2Asset2Classifier?: string,
      maven2Asset2Extension?: string,
      maven2Asset3?: any,
      maven2Asset3Classifier?: string,
      maven2Asset3Extension?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ComponentsApiAxiosParamCreator(
        configuration,
      ).uploadComponent(
        repository,
        yumDirectory,
        yumAsset,
        yumAssetFilename,
        dockerAsset,
        rAsset,
        rAssetPathId,
        pypiAsset,
        aptAsset,
        rubygemsAsset,
        npmAsset,
        nugetAsset,
        helmAsset,
        rawDirectory,
        rawAsset1,
        rawAsset1Filename,
        rawAsset2,
        rawAsset2Filename,
        rawAsset3,
        rawAsset3Filename,
        maven2GroupId,
        maven2ArtifactId,
        maven2Version,
        maven2GeneratePom,
        maven2Packaging,
        maven2Asset1,
        maven2Asset1Classifier,
        maven2Asset1Extension,
        maven2Asset2,
        maven2Asset2Classifier,
        maven2Asset2Extension,
        maven2Asset3,
        maven2Asset3Classifier,
        maven2Asset3Extension,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ComponentsApi - factory interface
 * @export
 */
export const ComponentsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Delete a single component
     * @param {string} id ID of the component to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteComponent(id: string, options?: any): AxiosPromise<void> {
      return ComponentsApiFp(configuration)
        .deleteComponent(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a single component
     * @param {string} id ID of the component to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComponentById(id: string, options?: any): AxiosPromise<ComponentXO> {
      return ComponentsApiFp(configuration)
        .getComponentById(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List components
     * @param {string} repository Repository from which you would like to retrieve components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getComponents(
      repository: string,
      continuationToken?: string,
      options?: any,
    ): AxiosPromise<PageComponentXO> {
      return ComponentsApiFp(configuration)
        .getComponents(repository, continuationToken, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Upload a single component
     * @param {string} repository Name of the repository to which you would like to upload the component
     * @param {string} [yumDirectory] yum Directory
     * @param {any} [yumAsset] yum Asset
     * @param {string} [yumAssetFilename] yum Asset  Filename
     * @param {any} [dockerAsset] docker Asset
     * @param {any} [rAsset] r Asset
     * @param {string} [rAssetPathId] r Asset  Package Path
     * @param {any} [pypiAsset] pypi Asset
     * @param {any} [aptAsset] apt Asset
     * @param {any} [rubygemsAsset] rubygems Asset
     * @param {any} [npmAsset] npm Asset
     * @param {any} [nugetAsset] nuget Asset
     * @param {any} [helmAsset] helm Asset
     * @param {string} [rawDirectory] raw Directory
     * @param {any} [rawAsset1] raw Asset 1
     * @param {string} [rawAsset1Filename] raw Asset 1 Filename
     * @param {any} [rawAsset2] raw Asset 2
     * @param {string} [rawAsset2Filename] raw Asset 2 Filename
     * @param {any} [rawAsset3] raw Asset 3
     * @param {string} [rawAsset3Filename] raw Asset 3 Filename
     * @param {string} [maven2GroupId] maven2 Group ID
     * @param {string} [maven2ArtifactId] maven2 Artifact ID
     * @param {string} [maven2Version] maven2 Version
     * @param {boolean} [maven2GeneratePom] maven2 Generate a POM file with these coordinates
     * @param {string} [maven2Packaging] maven2 Packaging
     * @param {any} [maven2Asset1] maven2 Asset 1
     * @param {string} [maven2Asset1Classifier] maven2 Asset 1 Classifier
     * @param {string} [maven2Asset1Extension] maven2 Asset 1 Extension
     * @param {any} [maven2Asset2] maven2 Asset 2
     * @param {string} [maven2Asset2Classifier] maven2 Asset 2 Classifier
     * @param {string} [maven2Asset2Extension] maven2 Asset 2 Extension
     * @param {any} [maven2Asset3] maven2 Asset 3
     * @param {string} [maven2Asset3Classifier] maven2 Asset 3 Classifier
     * @param {string} [maven2Asset3Extension] maven2 Asset 3 Extension
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    uploadComponent(
      repository: string,
      yumDirectory?: string,
      yumAsset?: any,
      yumAssetFilename?: string,
      dockerAsset?: any,
      rAsset?: any,
      rAssetPathId?: string,
      pypiAsset?: any,
      aptAsset?: any,
      rubygemsAsset?: any,
      npmAsset?: any,
      nugetAsset?: any,
      helmAsset?: any,
      rawDirectory?: string,
      rawAsset1?: any,
      rawAsset1Filename?: string,
      rawAsset2?: any,
      rawAsset2Filename?: string,
      rawAsset3?: any,
      rawAsset3Filename?: string,
      maven2GroupId?: string,
      maven2ArtifactId?: string,
      maven2Version?: string,
      maven2GeneratePom?: boolean,
      maven2Packaging?: string,
      maven2Asset1?: any,
      maven2Asset1Classifier?: string,
      maven2Asset1Extension?: string,
      maven2Asset2?: any,
      maven2Asset2Classifier?: string,
      maven2Asset2Extension?: string,
      maven2Asset3?: any,
      maven2Asset3Classifier?: string,
      maven2Asset3Extension?: string,
      options?: any,
    ): AxiosPromise<void> {
      return ComponentsApiFp(configuration)
        .uploadComponent(
          repository,
          yumDirectory,
          yumAsset,
          yumAssetFilename,
          dockerAsset,
          rAsset,
          rAssetPathId,
          pypiAsset,
          aptAsset,
          rubygemsAsset,
          npmAsset,
          nugetAsset,
          helmAsset,
          rawDirectory,
          rawAsset1,
          rawAsset1Filename,
          rawAsset2,
          rawAsset2Filename,
          rawAsset3,
          rawAsset3Filename,
          maven2GroupId,
          maven2ArtifactId,
          maven2Version,
          maven2GeneratePom,
          maven2Packaging,
          maven2Asset1,
          maven2Asset1Classifier,
          maven2Asset1Extension,
          maven2Asset2,
          maven2Asset2Classifier,
          maven2Asset2Extension,
          maven2Asset3,
          maven2Asset3Classifier,
          maven2Asset3Extension,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ComponentsApi - object-oriented interface
 * @export
 * @class ComponentsApi
 * @extends {BaseAPI}
 */
export class ComponentsApi extends BaseAPI {
  /**
   *
   * @summary Delete a single component
   * @param {string} id ID of the component to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public deleteComponent(id: string, options?: any) {
    return ComponentsApiFp(this.configuration)
      .deleteComponent(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a single component
   * @param {string} id ID of the component to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public getComponentById(id: string, options?: any) {
    return ComponentsApiFp(this.configuration)
      .getComponentById(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List components
   * @param {string} repository Repository from which you would like to retrieve components
   * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public getComponents(
    repository: string,
    continuationToken?: string,
    options?: any,
  ) {
    return ComponentsApiFp(this.configuration)
      .getComponents(repository, continuationToken, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Upload a single component
   * @param {string} repository Name of the repository to which you would like to upload the component
   * @param {string} [yumDirectory] yum Directory
   * @param {any} [yumAsset] yum Asset
   * @param {string} [yumAssetFilename] yum Asset  Filename
   * @param {any} [dockerAsset] docker Asset
   * @param {any} [rAsset] r Asset
   * @param {string} [rAssetPathId] r Asset  Package Path
   * @param {any} [pypiAsset] pypi Asset
   * @param {any} [aptAsset] apt Asset
   * @param {any} [rubygemsAsset] rubygems Asset
   * @param {any} [npmAsset] npm Asset
   * @param {any} [nugetAsset] nuget Asset
   * @param {any} [helmAsset] helm Asset
   * @param {string} [rawDirectory] raw Directory
   * @param {any} [rawAsset1] raw Asset 1
   * @param {string} [rawAsset1Filename] raw Asset 1 Filename
   * @param {any} [rawAsset2] raw Asset 2
   * @param {string} [rawAsset2Filename] raw Asset 2 Filename
   * @param {any} [rawAsset3] raw Asset 3
   * @param {string} [rawAsset3Filename] raw Asset 3 Filename
   * @param {string} [maven2GroupId] maven2 Group ID
   * @param {string} [maven2ArtifactId] maven2 Artifact ID
   * @param {string} [maven2Version] maven2 Version
   * @param {boolean} [maven2GeneratePom] maven2 Generate a POM file with these coordinates
   * @param {string} [maven2Packaging] maven2 Packaging
   * @param {any} [maven2Asset1] maven2 Asset 1
   * @param {string} [maven2Asset1Classifier] maven2 Asset 1 Classifier
   * @param {string} [maven2Asset1Extension] maven2 Asset 1 Extension
   * @param {any} [maven2Asset2] maven2 Asset 2
   * @param {string} [maven2Asset2Classifier] maven2 Asset 2 Classifier
   * @param {string} [maven2Asset2Extension] maven2 Asset 2 Extension
   * @param {any} [maven2Asset3] maven2 Asset 3
   * @param {string} [maven2Asset3Classifier] maven2 Asset 3 Classifier
   * @param {string} [maven2Asset3Extension] maven2 Asset 3 Extension
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ComponentsApi
   */
  public uploadComponent(
    repository: string,
    yumDirectory?: string,
    yumAsset?: any,
    yumAssetFilename?: string,
    dockerAsset?: any,
    rAsset?: any,
    rAssetPathId?: string,
    pypiAsset?: any,
    aptAsset?: any,
    rubygemsAsset?: any,
    npmAsset?: any,
    nugetAsset?: any,
    helmAsset?: any,
    rawDirectory?: string,
    rawAsset1?: any,
    rawAsset1Filename?: string,
    rawAsset2?: any,
    rawAsset2Filename?: string,
    rawAsset3?: any,
    rawAsset3Filename?: string,
    maven2GroupId?: string,
    maven2ArtifactId?: string,
    maven2Version?: string,
    maven2GeneratePom?: boolean,
    maven2Packaging?: string,
    maven2Asset1?: any,
    maven2Asset1Classifier?: string,
    maven2Asset1Extension?: string,
    maven2Asset2?: any,
    maven2Asset2Classifier?: string,
    maven2Asset2Extension?: string,
    maven2Asset3?: any,
    maven2Asset3Classifier?: string,
    maven2Asset3Extension?: string,
    options?: any,
  ) {
    return ComponentsApiFp(this.configuration)
      .uploadComponent(
        repository,
        yumDirectory,
        yumAsset,
        yumAssetFilename,
        dockerAsset,
        rAsset,
        rAssetPathId,
        pypiAsset,
        aptAsset,
        rubygemsAsset,
        npmAsset,
        nugetAsset,
        helmAsset,
        rawDirectory,
        rawAsset1,
        rawAsset1Filename,
        rawAsset2,
        rawAsset2Filename,
        rawAsset3,
        rawAsset3Filename,
        maven2GroupId,
        maven2ArtifactId,
        maven2Version,
        maven2GeneratePom,
        maven2Packaging,
        maven2Asset1,
        maven2Asset1Classifier,
        maven2Asset1Extension,
        maven2Asset2,
        maven2Asset2Classifier,
        maven2Asset2Extension,
        maven2Asset3,
        maven2Asset3Classifier,
        maven2Asset3Extension,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ContentSelectorsApi - axios parameter creator
 * @export
 */
export const ContentSelectorsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a new content selector
     * @param {ContentSelectorApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContentSelector: async (
      body?: ContentSelectorApiCreateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/content-selectors`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a content selector
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContentSelector: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteContentSelector.',
        )
      }
      const localVarPath = `/v1/security/content-selectors/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a content selector by name
     * @param {string} name The content selector name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContentSelector: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getContentSelector.',
        )
      }
      const localVarPath = `/v1/security/content-selectors/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List content selectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContentSelectors: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/content-selectors`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a content selector
     * @param {string} name The content selector name
     * @param {ContentSelectorApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentSelector: async (
      name: string,
      body?: ContentSelectorApiUpdateRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updateContentSelector.',
        )
      }
      const localVarPath = `/v1/security/content-selectors/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ContentSelectorsApi - functional programming interface
 * @export
 */
export const ContentSelectorsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a new content selector
     * @param {ContentSelectorApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createContentSelector(
      body?: ContentSelectorApiCreateRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ContentSelectorsApiAxiosParamCreator(
        configuration,
      ).createContentSelector(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete a content selector
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteContentSelector(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ContentSelectorsApiAxiosParamCreator(
        configuration,
      ).deleteContentSelector(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get a content selector by name
     * @param {string} name The content selector name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContentSelector(
      name: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ContentSelectorApiResponse>
    > {
      const localVarAxiosArgs = await ContentSelectorsApiAxiosParamCreator(
        configuration,
      ).getContentSelector(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List content selectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getContentSelectors(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ContentSelectorApiResponse>>
    > {
      const localVarAxiosArgs = await ContentSelectorsApiAxiosParamCreator(
        configuration,
      ).getContentSelectors(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a content selector
     * @param {string} name The content selector name
     * @param {ContentSelectorApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateContentSelector(
      name: string,
      body?: ContentSelectorApiUpdateRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ContentSelectorsApiAxiosParamCreator(
        configuration,
      ).updateContentSelector(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ContentSelectorsApi - factory interface
 * @export
 */
export const ContentSelectorsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Create a new content selector
     * @param {ContentSelectorApiCreateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createContentSelector(
      body?: ContentSelectorApiCreateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return ContentSelectorsApiFp(configuration)
        .createContentSelector(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a content selector
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteContentSelector(name: string, options?: any): AxiosPromise<void> {
      return ContentSelectorsApiFp(configuration)
        .deleteContentSelector(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a content selector by name
     * @param {string} name The content selector name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContentSelector(
      name: string,
      options?: any,
    ): AxiosPromise<ContentSelectorApiResponse> {
      return ContentSelectorsApiFp(configuration)
        .getContentSelector(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List content selectors
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getContentSelectors(
      options?: any,
    ): AxiosPromise<Array<ContentSelectorApiResponse>> {
      return ContentSelectorsApiFp(configuration)
        .getContentSelectors(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a content selector
     * @param {string} name The content selector name
     * @param {ContentSelectorApiUpdateRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateContentSelector(
      name: string,
      body?: ContentSelectorApiUpdateRequest,
      options?: any,
    ): AxiosPromise<void> {
      return ContentSelectorsApiFp(configuration)
        .updateContentSelector(name, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ContentSelectorsApi - object-oriented interface
 * @export
 * @class ContentSelectorsApi
 * @extends {BaseAPI}
 */
export class ContentSelectorsApi extends BaseAPI {
  /**
   *
   * @summary Create a new content selector
   * @param {ContentSelectorApiCreateRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentSelectorsApi
   */
  public createContentSelector(
    body?: ContentSelectorApiCreateRequest,
    options?: any,
  ) {
    return ContentSelectorsApiFp(this.configuration)
      .createContentSelector(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a content selector
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentSelectorsApi
   */
  public deleteContentSelector(name: string, options?: any) {
    return ContentSelectorsApiFp(this.configuration)
      .deleteContentSelector(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a content selector by name
   * @param {string} name The content selector name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentSelectorsApi
   */
  public getContentSelector(name: string, options?: any) {
    return ContentSelectorsApiFp(this.configuration)
      .getContentSelector(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List content selectors
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentSelectorsApi
   */
  public getContentSelectors(options?: any) {
    return ContentSelectorsApiFp(this.configuration)
      .getContentSelectors(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a content selector
   * @param {string} name The content selector name
   * @param {ContentSelectorApiUpdateRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContentSelectorsApi
   */
  public updateContentSelector(
    name: string,
    body?: ContentSelectorApiUpdateRequest,
    options?: any,
  ) {
    return ContentSelectorsApiFp(this.configuration)
      .updateContentSelector(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * EmailApi - axios parameter creator
 * @export
 */
export const EmailApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Disable and clear the email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailConfiguration: async (
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/email`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Retrieve the current email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailConfiguration: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/email`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Set the current email configuration
     * @param {ApiEmailConfiguration} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEmailConfiguration: async (
      body: ApiEmailConfiguration,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling setEmailConfiguration.',
        )
      }
      const localVarPath = `/v1/email`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Send a test email to the email address provided in the request body
     * @param {string} body An email address to send a test email to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testEmailConfiguration: async (
      body: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling testEmailConfiguration.',
        )
      }
      const localVarPath = `/v1/email/verify`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Disable and clear the email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEmailConfiguration(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await EmailApiAxiosParamCreator(
        configuration,
      ).deleteEmailConfiguration(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Retrieve the current email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEmailConfiguration(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiEmailConfiguration>
    > {
      const localVarAxiosArgs = await EmailApiAxiosParamCreator(
        configuration,
      ).getEmailConfiguration(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Set the current email configuration
     * @param {ApiEmailConfiguration} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setEmailConfiguration(
      body: ApiEmailConfiguration,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await EmailApiAxiosParamCreator(
        configuration,
      ).setEmailConfiguration(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Send a test email to the email address provided in the request body
     * @param {string} body An email address to send a test email to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async testEmailConfiguration(
      body: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiEmailValidation>
    > {
      const localVarAxiosArgs = await EmailApiAxiosParamCreator(
        configuration,
      ).testEmailConfiguration(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Disable and clear the email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEmailConfiguration(options?: any): AxiosPromise<void> {
      return EmailApiFp(configuration)
        .deleteEmailConfiguration(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Retrieve the current email configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEmailConfiguration(options?: any): AxiosPromise<ApiEmailConfiguration> {
      return EmailApiFp(configuration)
        .getEmailConfiguration(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Set the current email configuration
     * @param {ApiEmailConfiguration} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setEmailConfiguration(
      body: ApiEmailConfiguration,
      options?: any,
    ): AxiosPromise<void> {
      return EmailApiFp(configuration)
        .setEmailConfiguration(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Send a test email to the email address provided in the request body
     * @param {string} body An email address to send a test email to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    testEmailConfiguration(
      body: string,
      options?: any,
    ): AxiosPromise<ApiEmailValidation> {
      return EmailApiFp(configuration)
        .testEmailConfiguration(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
  /**
   *
   * @summary Disable and clear the email configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public deleteEmailConfiguration(options?: any) {
    return EmailApiFp(this.configuration)
      .deleteEmailConfiguration(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Retrieve the current email configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public getEmailConfiguration(options?: any) {
    return EmailApiFp(this.configuration)
      .getEmailConfiguration(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Set the current email configuration
   * @param {ApiEmailConfiguration} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public setEmailConfiguration(body: ApiEmailConfiguration, options?: any) {
    return EmailApiFp(this.configuration)
      .setEmailConfiguration(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Send a test email to the email address provided in the request body
   * @param {string} body An email address to send a test email to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EmailApi
   */
  public testEmailConfiguration(body: string, options?: any) {
    return EmailApiFp(this.configuration)
      .testEmailConfiguration(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * FormatsApi - axios parameter creator
 * @export
 */
export const FormatsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get upload field requirements for each supported format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get1: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/formats/upload-specs`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get upload field requirements for the desired format
     * @param {string} format The desired repository format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get2: async (format: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'format' is not null or undefined
      if (format === null || format === undefined) {
        throw new RequiredError(
          'format',
          'Required parameter format was null or undefined when calling get2.',
        )
      }
      const localVarPath = `/v1/formats/{format}/upload-specs`.replace(
        `{${'format'}}`,
        encodeURIComponent(String(format)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * FormatsApi - functional programming interface
 * @export
 */
export const FormatsApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get upload field requirements for each supported format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get1(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<UploadDefinitionXO>>
    > {
      const localVarAxiosArgs = await FormatsApiAxiosParamCreator(
        configuration,
      ).get1(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get upload field requirements for the desired format
     * @param {string} format The desired repository format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get2(
      format: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<UploadDefinitionXO>
    > {
      const localVarAxiosArgs = await FormatsApiAxiosParamCreator(
        configuration,
      ).get2(format, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * FormatsApi - factory interface
 * @export
 */
export const FormatsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get upload field requirements for each supported format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get1(options?: any): AxiosPromise<Array<UploadDefinitionXO>> {
      return FormatsApiFp(configuration)
        .get1(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get upload field requirements for the desired format
     * @param {string} format The desired repository format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get2(format: string, options?: any): AxiosPromise<UploadDefinitionXO> {
      return FormatsApiFp(configuration)
        .get2(format, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * FormatsApi - object-oriented interface
 * @export
 * @class FormatsApi
 * @extends {BaseAPI}
 */
export class FormatsApi extends BaseAPI {
  /**
   *
   * @summary Get upload field requirements for each supported format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormatsApi
   */
  public get1(options?: any) {
    return FormatsApiFp(this.configuration)
      .get1(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get upload field requirements for the desired format
   * @param {string} format The desired repository format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FormatsApi
   */
  public get2(format: string, options?: any) {
    return FormatsApiFp(this.configuration)
      .get2(format, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * LifecycleApi - axios parameter creator
 * @export
 */
export const LifecycleApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Re-runs all phases from the given phase to the current phase
     * @summary Bounce lifecycle phase
     * @param {string} [body] The phase to bounce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bounce: async (body?: string, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/lifecycle/bounce`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'text/plain'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get current lifecycle phase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPhase: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/lifecycle/phase`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Move to new lifecycle phase
     * @param {string} [body] The phase to move to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPhase: async (
      body?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/lifecycle/phase`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'text/plain'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * LifecycleApi - functional programming interface
 * @export
 */
export const LifecycleApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Re-runs all phases from the given phase to the current phase
     * @summary Bounce lifecycle phase
     * @param {string} [body] The phase to bounce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bounce(
      body?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await LifecycleApiAxiosParamCreator(
        configuration,
      ).bounce(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get current lifecycle phase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPhase(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>
    > {
      const localVarAxiosArgs = await LifecycleApiAxiosParamCreator(
        configuration,
      ).getPhase(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Move to new lifecycle phase
     * @param {string} [body] The phase to move to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setPhase(
      body?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await LifecycleApiAxiosParamCreator(
        configuration,
      ).setPhase(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * LifecycleApi - factory interface
 * @export
 */
export const LifecycleApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Re-runs all phases from the given phase to the current phase
     * @summary Bounce lifecycle phase
     * @param {string} [body] The phase to bounce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bounce(body?: string, options?: any): AxiosPromise<void> {
      return LifecycleApiFp(configuration)
        .bounce(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get current lifecycle phase
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPhase(options?: any): AxiosPromise<string> {
      return LifecycleApiFp(configuration)
        .getPhase(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Move to new lifecycle phase
     * @param {string} [body] The phase to move to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setPhase(body?: string, options?: any): AxiosPromise<void> {
      return LifecycleApiFp(configuration)
        .setPhase(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * LifecycleApi - object-oriented interface
 * @export
 * @class LifecycleApi
 * @extends {BaseAPI}
 */
export class LifecycleApi extends BaseAPI {
  /**
   * Re-runs all phases from the given phase to the current phase
   * @summary Bounce lifecycle phase
   * @param {string} [body] The phase to bounce
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LifecycleApi
   */
  public bounce(body?: string, options?: any) {
    return LifecycleApiFp(this.configuration)
      .bounce(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get current lifecycle phase
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LifecycleApi
   */
  public getPhase(options?: any) {
    return LifecycleApiFp(this.configuration)
      .getPhase(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Move to new lifecycle phase
   * @param {string} [body] The phase to move to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof LifecycleApi
   */
  public setPhase(body?: string, options?: any) {
    return LifecycleApiFp(this.configuration)
      .setPhase(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ManageIQServerConfigurationApi - axios parameter creator
 * @export
 */
export const ManageIQServerConfigurationApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Disable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableIq: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/iq/disable`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Enable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableIq: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/iq/enable`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get IQ server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/iq`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update IQ server configuration
     * @param {IqConnectionXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration: async (
      body?: IqConnectionXo,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/iq`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Verify IQ server connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyConnection: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/iq/verify-connection`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ManageIQServerConfigurationApi - functional programming interface
 * @export
 */
export const ManageIQServerConfigurationApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Disable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disableIq(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ManageIQServerConfigurationApiAxiosParamCreator(
        configuration,
      ).disableIq(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Enable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableIq(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ManageIQServerConfigurationApiAxiosParamCreator(
        configuration,
      ).enableIq(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get IQ server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getConfiguration(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ManageIQServerConfigurationApiAxiosParamCreator(
        configuration,
      ).getConfiguration(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update IQ server configuration
     * @param {IqConnectionXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateConfiguration(
      body?: IqConnectionXo,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ManageIQServerConfigurationApiAxiosParamCreator(
        configuration,
      ).updateConfiguration(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Verify IQ server connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async verifyConnection(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ManageIQServerConfigurationApiAxiosParamCreator(
        configuration,
      ).verifyConnection(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ManageIQServerConfigurationApi - factory interface
 * @export
 */
export const ManageIQServerConfigurationApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Disable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableIq(options?: any): AxiosPromise<void> {
      return ManageIQServerConfigurationApiFp(configuration)
        .disableIq(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Enable IQ server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableIq(options?: any): AxiosPromise<void> {
      return ManageIQServerConfigurationApiFp(configuration)
        .enableIq(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get IQ server configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConfiguration(options?: any): AxiosPromise<void> {
      return ManageIQServerConfigurationApiFp(configuration)
        .getConfiguration(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update IQ server configuration
     * @param {IqConnectionXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateConfiguration(
      body?: IqConnectionXo,
      options?: any,
    ): AxiosPromise<void> {
      return ManageIQServerConfigurationApiFp(configuration)
        .updateConfiguration(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Verify IQ server connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    verifyConnection(options?: any): AxiosPromise<void> {
      return ManageIQServerConfigurationApiFp(configuration)
        .verifyConnection(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ManageIQServerConfigurationApi - object-oriented interface
 * @export
 * @class ManageIQServerConfigurationApi
 * @extends {BaseAPI}
 */
export class ManageIQServerConfigurationApi extends BaseAPI {
  /**
   *
   * @summary Disable IQ server
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManageIQServerConfigurationApi
   */
  public disableIq(options?: any) {
    return ManageIQServerConfigurationApiFp(this.configuration)
      .disableIq(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Enable IQ server
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManageIQServerConfigurationApi
   */
  public enableIq(options?: any) {
    return ManageIQServerConfigurationApiFp(this.configuration)
      .enableIq(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get IQ server configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManageIQServerConfigurationApi
   */
  public getConfiguration(options?: any) {
    return ManageIQServerConfigurationApiFp(this.configuration)
      .getConfiguration(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update IQ server configuration
   * @param {IqConnectionXo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManageIQServerConfigurationApi
   */
  public updateConfiguration(body?: IqConnectionXo, options?: any) {
    return ManageIQServerConfigurationApiFp(this.configuration)
      .updateConfiguration(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Verify IQ server connection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ManageIQServerConfigurationApi
   */
  public verifyConnection(options?: any) {
    return ManageIQServerConfigurationApiFp(this.configuration)
      .verifyConnection(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ProductLicensingApi - axios parameter creator
 * @export
 */
export const ProductLicensingApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get the current license status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseStatus: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/system/license`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Uninstall license if present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLicense: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/system/license`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Server must be restarted to take effect
     * @summary Upload a new license file.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLicense: async (
      body?: object,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/system/license`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/octet-stream'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ProductLicensingApi - functional programming interface
 * @export
 */
export const ProductLicensingApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get the current license status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLicenseStatus(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiLicenseDetailsXO>
    > {
      const localVarAxiosArgs = await ProductLicensingApiAxiosParamCreator(
        configuration,
      ).getLicenseStatus(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Uninstall license if present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeLicense(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ProductLicensingApiAxiosParamCreator(
        configuration,
      ).removeLicense(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Server must be restarted to take effect
     * @summary Upload a new license file.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setLicense(
      body?: object,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<ApiLicenseDetailsXO>
    > {
      const localVarAxiosArgs = await ProductLicensingApiAxiosParamCreator(
        configuration,
      ).setLicense(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ProductLicensingApi - factory interface
 * @export
 */
export const ProductLicensingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get the current license status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLicenseStatus(options?: any): AxiosPromise<ApiLicenseDetailsXO> {
      return ProductLicensingApiFp(configuration)
        .getLicenseStatus(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Uninstall license if present.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeLicense(options?: any): AxiosPromise<void> {
      return ProductLicensingApiFp(configuration)
        .removeLicense(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Server must be restarted to take effect
     * @summary Upload a new license file.
     * @param {object} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setLicense(
      body?: object,
      options?: any,
    ): AxiosPromise<ApiLicenseDetailsXO> {
      return ProductLicensingApiFp(configuration)
        .setLicense(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ProductLicensingApi - object-oriented interface
 * @export
 * @class ProductLicensingApi
 * @extends {BaseAPI}
 */
export class ProductLicensingApi extends BaseAPI {
  /**
   *
   * @summary Get the current license status.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductLicensingApi
   */
  public getLicenseStatus(options?: any) {
    return ProductLicensingApiFp(this.configuration)
      .getLicenseStatus(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Uninstall license if present.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductLicensingApi
   */
  public removeLicense(options?: any) {
    return ProductLicensingApiFp(this.configuration)
      .removeLicense(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Server must be restarted to take effect
   * @summary Upload a new license file.
   * @param {object} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ProductLicensingApi
   */
  public setLicense(body?: object, options?: any) {
    return ProductLicensingApiFp(this.configuration)
      .setLicense(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ReadOnlyApi - axios parameter creator
 * @export
 */
export const ReadOnlyApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     * Forcibly release read-only status, including System initiated tasks. Warning: may result in data loss.
     * @summary Forcibly release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forceRelease: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/read-only/force-release`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Enable read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freeze: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/read-only/freeze`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get read-only state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/read-only`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Release administrator initiated read-only status. Will not release read-only caused by system tasks.
     * @summary Release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    release: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/read-only/release`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ReadOnlyApi - functional programming interface
 * @export
 */
export const ReadOnlyApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Forcibly release read-only status, including System initiated tasks. Warning: may result in data loss.
     * @summary Forcibly release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forceRelease(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ReadOnlyApiAxiosParamCreator(
        configuration,
      ).forceRelease(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Enable read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async freeze(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ReadOnlyApiAxiosParamCreator(
        configuration,
      ).freeze(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get read-only state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async get(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReadOnlyState>
    > {
      const localVarAxiosArgs = await ReadOnlyApiAxiosParamCreator(
        configuration,
      ).get(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Release administrator initiated read-only status. Will not release read-only caused by system tasks.
     * @summary Release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async release(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ReadOnlyApiAxiosParamCreator(
        configuration,
      ).release(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ReadOnlyApi - factory interface
 * @export
 */
export const ReadOnlyApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Forcibly release read-only status, including System initiated tasks. Warning: may result in data loss.
     * @summary Forcibly release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forceRelease(options?: any): AxiosPromise<void> {
      return ReadOnlyApiFp(configuration)
        .forceRelease(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Enable read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    freeze(options?: any): AxiosPromise<void> {
      return ReadOnlyApiFp(configuration)
        .freeze(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get read-only state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(options?: any): AxiosPromise<ReadOnlyState> {
      return ReadOnlyApiFp(configuration)
        .get(options)
        .then((request) => request(axios, basePath))
    },
    /**
     * Release administrator initiated read-only status. Will not release read-only caused by system tasks.
     * @summary Release read-only
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    release(options?: any): AxiosPromise<void> {
      return ReadOnlyApiFp(configuration)
        .release(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ReadOnlyApi - object-oriented interface
 * @export
 * @class ReadOnlyApi
 * @extends {BaseAPI}
 */
export class ReadOnlyApi extends BaseAPI {
  /**
   * Forcibly release read-only status, including System initiated tasks. Warning: may result in data loss.
   * @summary Forcibly release read-only
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadOnlyApi
   */
  public forceRelease(options?: any) {
    return ReadOnlyApiFp(this.configuration)
      .forceRelease(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Enable read-only
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadOnlyApi
   */
  public freeze(options?: any) {
    return ReadOnlyApiFp(this.configuration)
      .freeze(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get read-only state
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadOnlyApi
   */
  public get(options?: any) {
    return ReadOnlyApiFp(this.configuration)
      .get(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Release administrator initiated read-only status. Will not release read-only caused by system tasks.
   * @summary Release read-only
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ReadOnlyApi
   */
  public release(options?: any) {
    return ReadOnlyApiFp(this.configuration)
      .release(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RepositoriesApi - axios parameter creator
 * @export
 */
export const RepositoriesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories1: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RepositoriesApi - functional programming interface
 * @export
 */
export const RepositoriesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepositories1(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RepositoryXO>>
    > {
      const localVarAxiosArgs = await RepositoriesApiAxiosParamCreator(
        configuration,
      ).getRepositories1(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RepositoriesApi - factory interface
 * @export
 */
export const RepositoriesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories1(options?: any): AxiosPromise<Array<RepositoryXO>> {
      return RepositoriesApiFp(configuration)
        .getRepositories1(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RepositoriesApi - object-oriented interface
 * @export
 * @class RepositoriesApi
 * @extends {BaseAPI}
 */
export class RepositoriesApi extends BaseAPI {
  /**
   *
   * @summary List repositories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoriesApi
   */
  public getRepositories1(options?: any) {
    return RepositoriesApiFp(this.configuration)
      .getRepositories1(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RepositoryManagementApi - axios parameter creator
 * @export
 */
export const RepositoryManagementApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Maven group repository
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository: async (
      body?: MavenGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/maven/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Maven hosted repository
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository1: async (
      body?: MavenHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/maven/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create NuGet proxy repository
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository10: async (
      body?: NugetProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/nuget/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create npm group repository
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository11: async (
      body?: NpmGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/npm/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create npm hosted repository
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository12: async (
      body?: NpmHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/npm/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create npm proxy repository
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository13: async (
      body?: NpmProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/npm/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create RubyGems group repository
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository14: async (
      body?: RubyGemsGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/rubygems/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create RubyGems hosted repository
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository15: async (
      body?: RubyGemsHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/rubygems/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create RubyGems proxy repository
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository16: async (
      body?: RubyGemsProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/rubygems/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create APT hosted repository
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository17: async (
      body?: AptHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/apt/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create APT proxy repository
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository18: async (
      body?: AptProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/apt/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Cocoapods proxy repository
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository19: async (
      body?: CocoapodsProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/cocoapods/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Maven proxy repository
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository2: async (
      body?: MavenProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/maven/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a Go group repository
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository20: async (
      body?: GolangGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/go/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a Go proxy repository
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository21: async (
      body?: GolangProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/go/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create PyPI group repository
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository22: async (
      body?: PypiGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/pypi/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create PyPI hosted repository
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository23: async (
      body?: PypiHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/pypi/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create PyPI proxy repository
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository24: async (
      body?: PypiProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/pypi/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Conan proxy repository
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository25: async (
      body?: ConanProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/conan/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create p2 proxy repository
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository26: async (
      body?: P2ProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/p2/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create R group repository
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository27: async (
      body?: RGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/r/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create R hosted repository
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository28: async (
      body?: RHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/r/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create R proxy repository
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository29: async (
      body?: RProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/r/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create raw group repository
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository3: async (
      body?: RawGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/raw/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Bower group repository
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository30: async (
      body?: BowerGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/bower/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Bower hosted repository
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository31: async (
      body?: BowerHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/bower/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Bower proxy repository
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository32: async (
      body?: BowerProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/bower/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Docker group repository
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository33: async (
      body?: DockerGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/docker/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Docker hosted repository
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository34: async (
      body?: DockerHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/docker/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Docker proxy repository
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository35: async (
      body?: DockerProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/docker/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Git LFS hosted repository
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository36: async (
      body?: GitLfsHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/gitlfs/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Yum group repository
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository37: async (
      body?: YumGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/yum/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Yum hosted repository
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository38: async (
      body?: YumHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/yum/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Yum proxy repository
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository39: async (
      body?: YumProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/yum/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create raw hosted repository
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository4: async (
      body?: RawHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/raw/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create raw proxy repository
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository5: async (
      body?: RawProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/raw/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Helm hosted repository
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository6: async (
      body?: HelmHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/helm/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create Helm proxy repository
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository7: async (
      body?: HelmProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/helm/proxy`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create NuGet group repository
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository8: async (
      body?: NugetGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/nuget/group`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create NuGet hosted repository
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository9: async (
      body?: NugetHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositories/nuget/hosted`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete repository of any format
     * @param {string} repositoryName Name of the repository to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepository: async (
      repositoryName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling deleteRepository.',
        )
      }
      const localVarPath = `/v1/repositories/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Disable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to disable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableRepositoryHealthCheck: async (
      repositoryName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling disableRepositoryHealthCheck.',
        )
      }
      const localVarPath = `/v1/repositories/{repositoryName}/health-check`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Enable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to enable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableRepositoryHealthCheck: async (
      repositoryName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling enableRepositoryHealthCheck.',
        )
      }
      const localVarPath = `/v1/repositories/{repositoryName}/health-check`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/repositorySettings`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Invalidate repository cache. Proxy or group repositories only.
     * @param {string} repositoryName Name of the repository to invalidate cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invalidateCache: async (
      repositoryName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling invalidateCache.',
        )
      }
      const localVarPath = `/v1/repositories/{repositoryName}/invalidate-cache`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Schedule a \'Repair - Rebuild repository search\' Task. Hosted or proxy repositories only.
     * @param {string} repositoryName Name of the repository to rebuild index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rebuildIndex: async (
      repositoryName: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling rebuildIndex.',
        )
      }
      const localVarPath = `/v1/repositories/{repositoryName}/rebuild-index`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Maven group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository: async (
      repositoryName: string,
      body?: MavenGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository.',
        )
      }
      const localVarPath = `/v1/repositories/maven/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Maven hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository1: async (
      repositoryName: string,
      body?: MavenHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository1.',
        )
      }
      const localVarPath = `/v1/repositories/maven/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update NuGet proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository10: async (
      repositoryName: string,
      body?: NugetProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository10.',
        )
      }
      const localVarPath = `/v1/repositories/nuget/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update npm group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository11: async (
      repositoryName: string,
      body?: NpmGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository11.',
        )
      }
      const localVarPath = `/v1/repositories/npm/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update npm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository12: async (
      repositoryName: string,
      body?: NpmHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository12.',
        )
      }
      const localVarPath = `/v1/repositories/npm/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update npm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository13: async (
      repositoryName: string,
      body?: NpmProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository13.',
        )
      }
      const localVarPath = `/v1/repositories/npm/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RubyGems group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository14: async (
      repositoryName: string,
      body?: RubyGemsGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository14.',
        )
      }
      const localVarPath = `/v1/repositories/rubygems/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RubyGems hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository15: async (
      repositoryName: string,
      body?: RubyGemsHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository15.',
        )
      }
      const localVarPath = `/v1/repositories/rubygems/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update RubyGems proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository16: async (
      repositoryName: string,
      body?: RubyGemsProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository16.',
        )
      }
      const localVarPath = `/v1/repositories/rubygems/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update APT hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository17: async (
      repositoryName: string,
      body?: AptHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository17.',
        )
      }
      const localVarPath = `/v1/repositories/apt/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update APT proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository18: async (
      repositoryName: string,
      body?: AptProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository18.',
        )
      }
      const localVarPath = `/v1/repositories/apt/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Cocoapods proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository19: async (
      repositoryName: string,
      body?: CocoapodsProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository19.',
        )
      }
      const localVarPath = `/v1/repositories/cocoapods/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Maven proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository2: async (
      repositoryName: string,
      body?: MavenProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository2.',
        )
      }
      const localVarPath = `/v1/repositories/maven/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a Go group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository20: async (
      repositoryName: string,
      body?: GolangGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository20.',
        )
      }
      const localVarPath = `/v1/repositories/go/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a Go proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository21: async (
      repositoryName: string,
      body?: GolangProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository21.',
        )
      }
      const localVarPath = `/v1/repositories/go/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update PyPI group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository22: async (
      repositoryName: string,
      body?: PypiGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository22.',
        )
      }
      const localVarPath = `/v1/repositories/pypi/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update PyPI hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository23: async (
      repositoryName: string,
      body?: PypiHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository23.',
        )
      }
      const localVarPath = `/v1/repositories/pypi/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update PyPI proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository24: async (
      repositoryName: string,
      body?: PypiProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository24.',
        )
      }
      const localVarPath = `/v1/repositories/pypi/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Conan proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository25: async (
      repositoryName: string,
      body?: ConanProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository25.',
        )
      }
      const localVarPath = `/v1/repositories/conan/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update p2 proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository26: async (
      repositoryName: string,
      body?: P2ProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository26.',
        )
      }
      const localVarPath = `/v1/repositories/p2/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update R group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository27: async (
      repositoryName: string,
      body?: RGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository27.',
        )
      }
      const localVarPath = `/v1/repositories/r/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update R hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository28: async (
      repositoryName: string,
      body?: RHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository28.',
        )
      }
      const localVarPath = `/v1/repositories/r/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update R proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository29: async (
      repositoryName: string,
      body?: RProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository29.',
        )
      }
      const localVarPath = `/v1/repositories/r/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update raw group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository3: async (
      repositoryName: string,
      body?: RawGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository3.',
        )
      }
      const localVarPath = `/v1/repositories/raw/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Bower group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository30: async (
      repositoryName: string,
      body?: BowerGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository30.',
        )
      }
      const localVarPath = `/v1/repositories/bower/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Bower hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository31: async (
      repositoryName: string,
      body?: BowerHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository31.',
        )
      }
      const localVarPath = `/v1/repositories/bower/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Bower proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository32: async (
      repositoryName: string,
      body?: BowerProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository32.',
        )
      }
      const localVarPath = `/v1/repositories/bower/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository33: async (
      repositoryName: string,
      body?: DockerGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository33.',
        )
      }
      const localVarPath = `/v1/repositories/docker/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Docker hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository34: async (
      repositoryName: string,
      body?: DockerHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository34.',
        )
      }
      const localVarPath = `/v1/repositories/docker/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository35: async (
      repositoryName: string,
      body?: DockerProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository35.',
        )
      }
      const localVarPath = `/v1/repositories/docker/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Git LFS hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository36: async (
      repositoryName: string,
      body?: GitLfsHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository36.',
        )
      }
      const localVarPath = `/v1/repositories/gitlfs/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Yum group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository37: async (
      repositoryName: string,
      body?: YumGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository37.',
        )
      }
      const localVarPath = `/v1/repositories/yum/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Yum hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository38: async (
      repositoryName: string,
      body?: YumHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository38.',
        )
      }
      const localVarPath = `/v1/repositories/yum/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Yum proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository39: async (
      repositoryName: string,
      body?: YumProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository39.',
        )
      }
      const localVarPath = `/v1/repositories/yum/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update raw hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository4: async (
      repositoryName: string,
      body?: RawHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository4.',
        )
      }
      const localVarPath = `/v1/repositories/raw/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update raw proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository5: async (
      repositoryName: string,
      body?: RawProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository5.',
        )
      }
      const localVarPath = `/v1/repositories/raw/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Helm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository6: async (
      repositoryName: string,
      body?: HelmHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository6.',
        )
      }
      const localVarPath = `/v1/repositories/helm/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Helm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository7: async (
      repositoryName: string,
      body?: HelmProxyRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository7.',
        )
      }
      const localVarPath = `/v1/repositories/helm/proxy/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update NuGet group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository8: async (
      repositoryName: string,
      body?: NugetGroupRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository8.',
        )
      }
      const localVarPath = `/v1/repositories/nuget/group/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update NuGet hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository9: async (
      repositoryName: string,
      body?: NugetHostedRepositoryApiRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'repositoryName' is not null or undefined
      if (repositoryName === null || repositoryName === undefined) {
        throw new RequiredError(
          'repositoryName',
          'Required parameter repositoryName was null or undefined when calling updateRepository9.',
        )
      }
      const localVarPath = `/v1/repositories/nuget/hosted/{repositoryName}`.replace(
        `{${'repositoryName'}}`,
        encodeURIComponent(String(repositoryName)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RepositoryManagementApi - functional programming interface
 * @export
 */
export const RepositoryManagementApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create Maven group repository
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository(
      body?: MavenGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Maven hosted repository
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository1(
      body?: MavenHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository1(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create NuGet proxy repository
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository10(
      body?: NugetProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository10(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create npm group repository
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository11(
      body?: NpmGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository11(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create npm hosted repository
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository12(
      body?: NpmHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository12(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create npm proxy repository
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository13(
      body?: NpmProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository13(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create RubyGems group repository
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository14(
      body?: RubyGemsGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository14(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create RubyGems hosted repository
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository15(
      body?: RubyGemsHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository15(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create RubyGems proxy repository
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository16(
      body?: RubyGemsProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository16(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create APT hosted repository
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository17(
      body?: AptHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository17(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create APT proxy repository
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository18(
      body?: AptProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository18(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Cocoapods proxy repository
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository19(
      body?: CocoapodsProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository19(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Maven proxy repository
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository2(
      body?: MavenProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository2(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a Go group repository
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository20(
      body?: GolangGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository20(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a Go proxy repository
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository21(
      body?: GolangProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository21(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create PyPI group repository
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository22(
      body?: PypiGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository22(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create PyPI hosted repository
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository23(
      body?: PypiHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository23(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create PyPI proxy repository
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository24(
      body?: PypiProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository24(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Conan proxy repository
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository25(
      body?: ConanProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository25(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create p2 proxy repository
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository26(
      body?: P2ProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository26(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create R group repository
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository27(
      body?: RGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository27(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create R hosted repository
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository28(
      body?: RHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository28(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create R proxy repository
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository29(
      body?: RProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository29(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create raw group repository
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository3(
      body?: RawGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository3(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Bower group repository
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository30(
      body?: BowerGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository30(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Bower hosted repository
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository31(
      body?: BowerHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository31(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Bower proxy repository
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository32(
      body?: BowerProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository32(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Docker group repository
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository33(
      body?: DockerGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository33(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Docker hosted repository
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository34(
      body?: DockerHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository34(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Docker proxy repository
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository35(
      body?: DockerProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository35(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Git LFS hosted repository
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository36(
      body?: GitLfsHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository36(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Yum group repository
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository37(
      body?: YumGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository37(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Yum hosted repository
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository38(
      body?: YumHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository38(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Yum proxy repository
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository39(
      body?: YumProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository39(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create raw hosted repository
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository4(
      body?: RawHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository4(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create raw proxy repository
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository5(
      body?: RawProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository5(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Helm hosted repository
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository6(
      body?: HelmHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository6(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create Helm proxy repository
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository7(
      body?: HelmProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository7(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create NuGet group repository
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository8(
      body?: NugetGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository8(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create NuGet hosted repository
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRepository9(
      body?: NugetHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).createRepository9(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete repository of any format
     * @param {string} repositoryName Name of the repository to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRepository(
      repositoryName: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).deleteRepository(repositoryName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Disable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to disable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async disableRepositoryHealthCheck(
      repositoryName: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).disableRepositoryHealthCheck(repositoryName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Enable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to enable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async enableRepositoryHealthCheck(
      repositoryName: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).enableRepositoryHealthCheck(repositoryName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRepositories(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<AbstractApiRepository>>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).getRepositories(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Invalidate repository cache. Proxy or group repositories only.
     * @param {string} repositoryName Name of the repository to invalidate cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async invalidateCache(
      repositoryName: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).invalidateCache(repositoryName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Schedule a \'Repair - Rebuild repository search\' Task. Hosted or proxy repositories only.
     * @param {string} repositoryName Name of the repository to rebuild index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async rebuildIndex(
      repositoryName: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).rebuildIndex(repositoryName, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Maven group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository(
      repositoryName: string,
      body?: MavenGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Maven hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository1(
      repositoryName: string,
      body?: MavenHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository1(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update NuGet proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository10(
      repositoryName: string,
      body?: NugetProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository10(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update npm group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository11(
      repositoryName: string,
      body?: NpmGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository11(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update npm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository12(
      repositoryName: string,
      body?: NpmHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository12(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update npm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository13(
      repositoryName: string,
      body?: NpmProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository13(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RubyGems group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository14(
      repositoryName: string,
      body?: RubyGemsGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository14(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RubyGems hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository15(
      repositoryName: string,
      body?: RubyGemsHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository15(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update RubyGems proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository16(
      repositoryName: string,
      body?: RubyGemsProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository16(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update APT hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository17(
      repositoryName: string,
      body?: AptHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository17(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update APT proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository18(
      repositoryName: string,
      body?: AptProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository18(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Cocoapods proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository19(
      repositoryName: string,
      body?: CocoapodsProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository19(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Maven proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository2(
      repositoryName: string,
      body?: MavenProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository2(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a Go group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository20(
      repositoryName: string,
      body?: GolangGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository20(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a Go proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository21(
      repositoryName: string,
      body?: GolangProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository21(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update PyPI group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository22(
      repositoryName: string,
      body?: PypiGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository22(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update PyPI hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository23(
      repositoryName: string,
      body?: PypiHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository23(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update PyPI proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository24(
      repositoryName: string,
      body?: PypiProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository24(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Conan proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository25(
      repositoryName: string,
      body?: ConanProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository25(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update p2 proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository26(
      repositoryName: string,
      body?: P2ProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository26(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update R group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository27(
      repositoryName: string,
      body?: RGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository27(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update R hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository28(
      repositoryName: string,
      body?: RHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository28(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update R proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository29(
      repositoryName: string,
      body?: RProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository29(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update raw group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository3(
      repositoryName: string,
      body?: RawGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository3(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Bower group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository30(
      repositoryName: string,
      body?: BowerGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository30(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Bower hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository31(
      repositoryName: string,
      body?: BowerHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository31(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Bower proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository32(
      repositoryName: string,
      body?: BowerProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository32(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository33(
      repositoryName: string,
      body?: DockerGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository33(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Docker hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository34(
      repositoryName: string,
      body?: DockerHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository34(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository35(
      repositoryName: string,
      body?: DockerProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository35(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Git LFS hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository36(
      repositoryName: string,
      body?: GitLfsHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository36(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Yum group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository37(
      repositoryName: string,
      body?: YumGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository37(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Yum hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository38(
      repositoryName: string,
      body?: YumHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository38(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Yum proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository39(
      repositoryName: string,
      body?: YumProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository39(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update raw hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository4(
      repositoryName: string,
      body?: RawHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository4(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update raw proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository5(
      repositoryName: string,
      body?: RawProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository5(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Helm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository6(
      repositoryName: string,
      body?: HelmHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository6(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Helm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository7(
      repositoryName: string,
      body?: HelmProxyRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository7(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update NuGet group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository8(
      repositoryName: string,
      body?: NugetGroupRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository8(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update NuGet hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRepository9(
      repositoryName: string,
      body?: NugetHostedRepositoryApiRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RepositoryManagementApiAxiosParamCreator(
        configuration,
      ).updateRepository9(repositoryName, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RepositoryManagementApi - factory interface
 * @export
 */
export const RepositoryManagementApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Create Maven group repository
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository(
      body?: MavenGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Maven hosted repository
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository1(
      body?: MavenHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository1(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create NuGet proxy repository
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository10(
      body?: NugetProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository10(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create npm group repository
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository11(
      body?: NpmGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository11(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create npm hosted repository
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository12(
      body?: NpmHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository12(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create npm proxy repository
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository13(
      body?: NpmProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository13(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create RubyGems group repository
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository14(
      body?: RubyGemsGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository14(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create RubyGems hosted repository
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository15(
      body?: RubyGemsHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository15(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create RubyGems proxy repository
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository16(
      body?: RubyGemsProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository16(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create APT hosted repository
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository17(
      body?: AptHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository17(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create APT proxy repository
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository18(
      body?: AptProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository18(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Cocoapods proxy repository
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository19(
      body?: CocoapodsProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository19(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Maven proxy repository
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository2(
      body?: MavenProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository2(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a Go group repository
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository20(
      body?: GolangGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository20(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a Go proxy repository
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository21(
      body?: GolangProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository21(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create PyPI group repository
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository22(
      body?: PypiGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository22(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create PyPI hosted repository
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository23(
      body?: PypiHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository23(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create PyPI proxy repository
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository24(
      body?: PypiProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository24(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Conan proxy repository
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository25(
      body?: ConanProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository25(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create p2 proxy repository
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository26(
      body?: P2ProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository26(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create R group repository
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository27(
      body?: RGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository27(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create R hosted repository
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository28(
      body?: RHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository28(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create R proxy repository
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository29(
      body?: RProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository29(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create raw group repository
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository3(
      body?: RawGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository3(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Bower group repository
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository30(
      body?: BowerGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository30(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Bower hosted repository
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository31(
      body?: BowerHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository31(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Bower proxy repository
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository32(
      body?: BowerProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository32(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Docker group repository
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository33(
      body?: DockerGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository33(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Docker hosted repository
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository34(
      body?: DockerHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository34(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Docker proxy repository
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository35(
      body?: DockerProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository35(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Git LFS hosted repository
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository36(
      body?: GitLfsHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository36(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Yum group repository
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository37(
      body?: YumGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository37(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Yum hosted repository
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository38(
      body?: YumHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository38(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Yum proxy repository
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository39(
      body?: YumProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository39(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create raw hosted repository
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository4(
      body?: RawHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository4(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create raw proxy repository
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository5(
      body?: RawProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository5(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Helm hosted repository
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository6(
      body?: HelmHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository6(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create Helm proxy repository
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository7(
      body?: HelmProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository7(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create NuGet group repository
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository8(
      body?: NugetGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository8(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create NuGet hosted repository
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRepository9(
      body?: NugetHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .createRepository9(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete repository of any format
     * @param {string} repositoryName Name of the repository to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRepository(
      repositoryName: string,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .deleteRepository(repositoryName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Disable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to disable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    disableRepositoryHealthCheck(
      repositoryName: string,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .disableRepositoryHealthCheck(repositoryName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Enable repository health check. Proxy repositories only.
     * @param {string} repositoryName Name of the repository to enable Repository Health Check for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    enableRepositoryHealthCheck(
      repositoryName: string,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .enableRepositoryHealthCheck(repositoryName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List repositories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRepositories(options?: any): AxiosPromise<Array<AbstractApiRepository>> {
      return RepositoryManagementApiFp(configuration)
        .getRepositories(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Invalidate repository cache. Proxy or group repositories only.
     * @param {string} repositoryName Name of the repository to invalidate cache
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    invalidateCache(repositoryName: string, options?: any): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .invalidateCache(repositoryName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Schedule a \'Repair - Rebuild repository search\' Task. Hosted or proxy repositories only.
     * @param {string} repositoryName Name of the repository to rebuild index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    rebuildIndex(repositoryName: string, options?: any): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .rebuildIndex(repositoryName, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Maven group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository(
      repositoryName: string,
      body?: MavenGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Maven hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository1(
      repositoryName: string,
      body?: MavenHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository1(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update NuGet proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository10(
      repositoryName: string,
      body?: NugetProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository10(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update npm group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository11(
      repositoryName: string,
      body?: NpmGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository11(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update npm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository12(
      repositoryName: string,
      body?: NpmHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository12(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update npm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NpmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository13(
      repositoryName: string,
      body?: NpmProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository13(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RubyGems group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository14(
      repositoryName: string,
      body?: RubyGemsGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository14(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RubyGems hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository15(
      repositoryName: string,
      body?: RubyGemsHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository15(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update RubyGems proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RubyGemsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository16(
      repositoryName: string,
      body?: RubyGemsProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository16(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update APT hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository17(
      repositoryName: string,
      body?: AptHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository17(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update APT proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {AptProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository18(
      repositoryName: string,
      body?: AptProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository18(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Cocoapods proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {CocoapodsProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository19(
      repositoryName: string,
      body?: CocoapodsProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository19(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Maven proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {MavenProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository2(
      repositoryName: string,
      body?: MavenProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository2(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a Go group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository20(
      repositoryName: string,
      body?: GolangGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository20(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a Go proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GolangProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository21(
      repositoryName: string,
      body?: GolangProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository21(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update PyPI group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository22(
      repositoryName: string,
      body?: PypiGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository22(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update PyPI hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository23(
      repositoryName: string,
      body?: PypiHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository23(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update PyPI proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {PypiProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository24(
      repositoryName: string,
      body?: PypiProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository24(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Conan proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {ConanProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository25(
      repositoryName: string,
      body?: ConanProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository25(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update p2 proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {P2ProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository26(
      repositoryName: string,
      body?: P2ProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository26(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update R group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository27(
      repositoryName: string,
      body?: RGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository27(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update R hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository28(
      repositoryName: string,
      body?: RHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository28(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update R proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository29(
      repositoryName: string,
      body?: RProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository29(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update raw group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository3(
      repositoryName: string,
      body?: RawGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository3(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Bower group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository30(
      repositoryName: string,
      body?: BowerGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository30(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Bower hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository31(
      repositoryName: string,
      body?: BowerHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository31(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Bower proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {BowerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository32(
      repositoryName: string,
      body?: BowerProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository32(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository33(
      repositoryName: string,
      body?: DockerGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository33(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Docker hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository34(
      repositoryName: string,
      body?: DockerHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository34(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Docker group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {DockerProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository35(
      repositoryName: string,
      body?: DockerProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository35(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Git LFS hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {GitLfsHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository36(
      repositoryName: string,
      body?: GitLfsHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository36(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Yum group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository37(
      repositoryName: string,
      body?: YumGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository37(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Yum hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository38(
      repositoryName: string,
      body?: YumHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository38(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Yum proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {YumProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository39(
      repositoryName: string,
      body?: YumProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository39(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update raw hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository4(
      repositoryName: string,
      body?: RawHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository4(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update raw proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {RawProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository5(
      repositoryName: string,
      body?: RawProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository5(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Helm hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository6(
      repositoryName: string,
      body?: HelmHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository6(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Helm proxy repository
     * @param {string} repositoryName Name of the repository to update
     * @param {HelmProxyRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository7(
      repositoryName: string,
      body?: HelmProxyRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository7(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update NuGet group repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetGroupRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository8(
      repositoryName: string,
      body?: NugetGroupRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository8(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update NuGet hosted repository
     * @param {string} repositoryName Name of the repository to update
     * @param {NugetHostedRepositoryApiRequest} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRepository9(
      repositoryName: string,
      body?: NugetHostedRepositoryApiRequest,
      options?: any,
    ): AxiosPromise<void> {
      return RepositoryManagementApiFp(configuration)
        .updateRepository9(repositoryName, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RepositoryManagementApi - object-oriented interface
 * @export
 * @class RepositoryManagementApi
 * @extends {BaseAPI}
 */
export class RepositoryManagementApi extends BaseAPI {
  /**
   *
   * @summary Create Maven group repository
   * @param {MavenGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository(
    body?: MavenGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Maven hosted repository
   * @param {MavenHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository1(
    body?: MavenHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository1(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create NuGet proxy repository
   * @param {NugetProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository10(
    body?: NugetProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository10(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create npm group repository
   * @param {NpmGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository11(
    body?: NpmGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository11(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create npm hosted repository
   * @param {NpmHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository12(
    body?: NpmHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository12(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create npm proxy repository
   * @param {NpmProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository13(
    body?: NpmProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository13(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create RubyGems group repository
   * @param {RubyGemsGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository14(
    body?: RubyGemsGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository14(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create RubyGems hosted repository
   * @param {RubyGemsHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository15(
    body?: RubyGemsHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository15(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create RubyGems proxy repository
   * @param {RubyGemsProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository16(
    body?: RubyGemsProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository16(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create APT hosted repository
   * @param {AptHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository17(
    body?: AptHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository17(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create APT proxy repository
   * @param {AptProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository18(
    body?: AptProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository18(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Cocoapods proxy repository
   * @param {CocoapodsProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository19(
    body?: CocoapodsProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository19(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Maven proxy repository
   * @param {MavenProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository2(
    body?: MavenProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository2(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a Go group repository
   * @param {GolangGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository20(
    body?: GolangGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository20(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a Go proxy repository
   * @param {GolangProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository21(
    body?: GolangProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository21(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create PyPI group repository
   * @param {PypiGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository22(
    body?: PypiGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository22(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create PyPI hosted repository
   * @param {PypiHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository23(
    body?: PypiHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository23(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create PyPI proxy repository
   * @param {PypiProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository24(
    body?: PypiProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository24(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Conan proxy repository
   * @param {ConanProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository25(
    body?: ConanProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository25(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create p2 proxy repository
   * @param {P2ProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository26(body?: P2ProxyRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository26(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create R group repository
   * @param {RGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository27(body?: RGroupRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository27(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create R hosted repository
   * @param {RHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository28(body?: RHostedRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository28(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create R proxy repository
   * @param {RProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository29(body?: RProxyRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository29(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create raw group repository
   * @param {RawGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository3(body?: RawGroupRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository3(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Bower group repository
   * @param {BowerGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository30(
    body?: BowerGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository30(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Bower hosted repository
   * @param {BowerHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository31(
    body?: BowerHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository31(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Bower proxy repository
   * @param {BowerProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository32(
    body?: BowerProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository32(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Docker group repository
   * @param {DockerGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository33(
    body?: DockerGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository33(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Docker hosted repository
   * @param {DockerHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository34(
    body?: DockerHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository34(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Docker proxy repository
   * @param {DockerProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository35(
    body?: DockerProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository35(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Git LFS hosted repository
   * @param {GitLfsHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository36(
    body?: GitLfsHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository36(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Yum group repository
   * @param {YumGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository37(
    body?: YumGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository37(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Yum hosted repository
   * @param {YumHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository38(
    body?: YumHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository38(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Yum proxy repository
   * @param {YumProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository39(
    body?: YumProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository39(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create raw hosted repository
   * @param {RawHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository4(
    body?: RawHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository4(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create raw proxy repository
   * @param {RawProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository5(body?: RawProxyRepositoryApiRequest, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository5(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Helm hosted repository
   * @param {HelmHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository6(
    body?: HelmHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository6(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create Helm proxy repository
   * @param {HelmProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository7(
    body?: HelmProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository7(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create NuGet group repository
   * @param {NugetGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository8(
    body?: NugetGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository8(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create NuGet hosted repository
   * @param {NugetHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public createRepository9(
    body?: NugetHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .createRepository9(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete repository of any format
   * @param {string} repositoryName Name of the repository to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public deleteRepository(repositoryName: string, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .deleteRepository(repositoryName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Disable repository health check. Proxy repositories only.
   * @param {string} repositoryName Name of the repository to disable Repository Health Check for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public disableRepositoryHealthCheck(repositoryName: string, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .disableRepositoryHealthCheck(repositoryName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Enable repository health check. Proxy repositories only.
   * @param {string} repositoryName Name of the repository to enable Repository Health Check for
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public enableRepositoryHealthCheck(repositoryName: string, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .enableRepositoryHealthCheck(repositoryName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List repositories
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public getRepositories(options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .getRepositories(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Invalidate repository cache. Proxy or group repositories only.
   * @param {string} repositoryName Name of the repository to invalidate cache
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public invalidateCache(repositoryName: string, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .invalidateCache(repositoryName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Schedule a \'Repair - Rebuild repository search\' Task. Hosted or proxy repositories only.
   * @param {string} repositoryName Name of the repository to rebuild index
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public rebuildIndex(repositoryName: string, options?: any) {
    return RepositoryManagementApiFp(this.configuration)
      .rebuildIndex(repositoryName, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Maven group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {MavenGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository(
    repositoryName: string,
    body?: MavenGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Maven hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {MavenHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository1(
    repositoryName: string,
    body?: MavenHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository1(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update NuGet proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NugetProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository10(
    repositoryName: string,
    body?: NugetProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository10(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update npm group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NpmGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository11(
    repositoryName: string,
    body?: NpmGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository11(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update npm hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NpmHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository12(
    repositoryName: string,
    body?: NpmHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository12(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update npm proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NpmProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository13(
    repositoryName: string,
    body?: NpmProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository13(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RubyGems group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RubyGemsGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository14(
    repositoryName: string,
    body?: RubyGemsGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository14(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RubyGems hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RubyGemsHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository15(
    repositoryName: string,
    body?: RubyGemsHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository15(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update RubyGems proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RubyGemsProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository16(
    repositoryName: string,
    body?: RubyGemsProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository16(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update APT hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {AptHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository17(
    repositoryName: string,
    body?: AptHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository17(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update APT proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {AptProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository18(
    repositoryName: string,
    body?: AptProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository18(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Cocoapods proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {CocoapodsProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository19(
    repositoryName: string,
    body?: CocoapodsProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository19(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Maven proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {MavenProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository2(
    repositoryName: string,
    body?: MavenProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository2(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a Go group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {GolangGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository20(
    repositoryName: string,
    body?: GolangGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository20(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a Go proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {GolangProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository21(
    repositoryName: string,
    body?: GolangProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository21(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update PyPI group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {PypiGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository22(
    repositoryName: string,
    body?: PypiGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository22(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update PyPI hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {PypiHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository23(
    repositoryName: string,
    body?: PypiHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository23(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update PyPI proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {PypiProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository24(
    repositoryName: string,
    body?: PypiProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository24(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Conan proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {ConanProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository25(
    repositoryName: string,
    body?: ConanProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository25(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update p2 proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {P2ProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository26(
    repositoryName: string,
    body?: P2ProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository26(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update R group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository27(
    repositoryName: string,
    body?: RGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository27(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update R hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository28(
    repositoryName: string,
    body?: RHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository28(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update R proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository29(
    repositoryName: string,
    body?: RProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository29(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update raw group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RawGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository3(
    repositoryName: string,
    body?: RawGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository3(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Bower group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {BowerGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository30(
    repositoryName: string,
    body?: BowerGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository30(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Bower hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {BowerHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository31(
    repositoryName: string,
    body?: BowerHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository31(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Bower proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {BowerProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository32(
    repositoryName: string,
    body?: BowerProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository32(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Docker group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {DockerGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository33(
    repositoryName: string,
    body?: DockerGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository33(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Docker hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {DockerHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository34(
    repositoryName: string,
    body?: DockerHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository34(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Docker group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {DockerProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository35(
    repositoryName: string,
    body?: DockerProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository35(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Git LFS hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {GitLfsHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository36(
    repositoryName: string,
    body?: GitLfsHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository36(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Yum group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {YumGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository37(
    repositoryName: string,
    body?: YumGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository37(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Yum hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {YumHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository38(
    repositoryName: string,
    body?: YumHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository38(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Yum proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {YumProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository39(
    repositoryName: string,
    body?: YumProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository39(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update raw hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RawHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository4(
    repositoryName: string,
    body?: RawHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository4(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update raw proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {RawProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository5(
    repositoryName: string,
    body?: RawProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository5(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Helm hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {HelmHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository6(
    repositoryName: string,
    body?: HelmHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository6(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Helm proxy repository
   * @param {string} repositoryName Name of the repository to update
   * @param {HelmProxyRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository7(
    repositoryName: string,
    body?: HelmProxyRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository7(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update NuGet group repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NugetGroupRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository8(
    repositoryName: string,
    body?: NugetGroupRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository8(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update NuGet hosted repository
   * @param {string} repositoryName Name of the repository to update
   * @param {NugetHostedRepositoryApiRequest} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RepositoryManagementApi
   */
  public updateRepository9(
    repositoryName: string,
    body?: NugetHostedRepositoryApiRequest,
    options?: any,
  ) {
    return RepositoryManagementApiFp(this.configuration)
      .updateRepository9(repositoryName, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * RoutingRulesApi - axios parameter creator
 * @export
 */
export const RoutingRulesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a single routing rule
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingRule: async (
      body: RoutingRuleXO,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling createRoutingRule.',
        )
      }
      const localVarPath = `/v1/routing-rules`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a single routing rule
     * @param {string} name The name of the routing rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingRule: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteRoutingRule.',
        )
      }
      const localVarPath = `/v1/routing-rules/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get a single routing rule
     * @param {string} name The name of the routing rule to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutingRule: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getRoutingRule.',
        )
      }
      const localVarPath = `/v1/routing-rules/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List routing rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutingRules: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/routing-rules`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a single routing rule
     * @param {string} name The name of the routing rule to update
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingRule: async (
      name: string,
      body: RoutingRuleXO,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updateRoutingRule.',
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateRoutingRule.',
        )
      }
      const localVarPath = `/v1/routing-rules/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * RoutingRulesApi - functional programming interface
 * @export
 */
export const RoutingRulesApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a single routing rule
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createRoutingRule(
      body: RoutingRuleXO,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RoutingRulesApiAxiosParamCreator(
        configuration,
      ).createRoutingRule(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete a single routing rule
     * @param {string} name The name of the routing rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteRoutingRule(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RoutingRulesApiAxiosParamCreator(
        configuration,
      ).deleteRoutingRule(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get a single routing rule
     * @param {string} name The name of the routing rule to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoutingRule(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutingRuleXO>
    > {
      const localVarAxiosArgs = await RoutingRulesApiAxiosParamCreator(
        configuration,
      ).getRoutingRule(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List routing rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoutingRules(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RoutingRuleXO>>
    > {
      const localVarAxiosArgs = await RoutingRulesApiAxiosParamCreator(
        configuration,
      ).getRoutingRules(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a single routing rule
     * @param {string} name The name of the routing rule to update
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateRoutingRule(
      name: string,
      body: RoutingRuleXO,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await RoutingRulesApiAxiosParamCreator(
        configuration,
      ).updateRoutingRule(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * RoutingRulesApi - factory interface
 * @export
 */
export const RoutingRulesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Create a single routing rule
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createRoutingRule(body: RoutingRuleXO, options?: any): AxiosPromise<void> {
      return RoutingRulesApiFp(configuration)
        .createRoutingRule(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a single routing rule
     * @param {string} name The name of the routing rule to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteRoutingRule(name: string, options?: any): AxiosPromise<void> {
      return RoutingRulesApiFp(configuration)
        .deleteRoutingRule(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get a single routing rule
     * @param {string} name The name of the routing rule to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutingRule(name: string, options?: any): AxiosPromise<RoutingRuleXO> {
      return RoutingRulesApiFp(configuration)
        .getRoutingRule(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List routing rules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoutingRules(options?: any): AxiosPromise<Array<RoutingRuleXO>> {
      return RoutingRulesApiFp(configuration)
        .getRoutingRules(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a single routing rule
     * @param {string} name The name of the routing rule to update
     * @param {RoutingRuleXO} body A routing rule configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateRoutingRule(
      name: string,
      body: RoutingRuleXO,
      options?: any,
    ): AxiosPromise<void> {
      return RoutingRulesApiFp(configuration)
        .updateRoutingRule(name, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * RoutingRulesApi - object-oriented interface
 * @export
 * @class RoutingRulesApi
 * @extends {BaseAPI}
 */
export class RoutingRulesApi extends BaseAPI {
  /**
   *
   * @summary Create a single routing rule
   * @param {RoutingRuleXO} body A routing rule configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingRulesApi
   */
  public createRoutingRule(body: RoutingRuleXO, options?: any) {
    return RoutingRulesApiFp(this.configuration)
      .createRoutingRule(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a single routing rule
   * @param {string} name The name of the routing rule to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingRulesApi
   */
  public deleteRoutingRule(name: string, options?: any) {
    return RoutingRulesApiFp(this.configuration)
      .deleteRoutingRule(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get a single routing rule
   * @param {string} name The name of the routing rule to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingRulesApi
   */
  public getRoutingRule(name: string, options?: any) {
    return RoutingRulesApiFp(this.configuration)
      .getRoutingRule(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List routing rules
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingRulesApi
   */
  public getRoutingRules(options?: any) {
    return RoutingRulesApiFp(this.configuration)
      .getRoutingRules(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a single routing rule
   * @param {string} name The name of the routing rule to update
   * @param {RoutingRuleXO} body A routing rule configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof RoutingRulesApi
   */
  public updateRoutingRule(name: string, body: RoutingRuleXO, options?: any) {
    return RoutingRulesApiFp(this.configuration)
      .updateRoutingRule(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * ScriptApi - axios parameter creator
 * @export
 */
export const ScriptApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Add a new script
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add: async (body?: ScriptXO, options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/script`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List all stored scripts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    browse: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/script`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete1: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling delete1.',
        )
      }
      const localVarPath = `/v1/script/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update stored script by name
     * @param {string} name
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit: async (
      name: string,
      body?: ScriptXO,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling edit.',
        )
      }
      const localVarPath = `/v1/script/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Read stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    read1: async (name: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling read1.',
        )
      }
      const localVarPath = `/v1/script/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Run stored script by name
     * @param {string} name
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    run1: async (
      name: string,
      body?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling run1.',
        )
      }
      const localVarPath = `/v1/script/{name}/run`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'text/plain'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * ScriptApi - functional programming interface
 * @export
 */
export const ScriptApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Add a new script
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async add(
      body?: ScriptXO,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).add(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List all stored scripts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async browse(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ScriptXO>>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).browse(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async delete1(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).delete1(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update stored script by name
     * @param {string} name
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async edit(
      name: string,
      body?: ScriptXO,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).edit(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Read stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async read1(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScriptXO>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).read1(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Run stored script by name
     * @param {string} name
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async run1(
      name: string,
      body?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScriptResultXO>
    > {
      const localVarAxiosArgs = await ScriptApiAxiosParamCreator(
        configuration,
      ).run1(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * ScriptApi - factory interface
 * @export
 */
export const ScriptApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Add a new script
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    add(body?: ScriptXO, options?: any): AxiosPromise<void> {
      return ScriptApiFp(configuration)
        .add(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List all stored scripts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    browse(options?: any): AxiosPromise<Array<ScriptXO>> {
      return ScriptApiFp(configuration)
        .browse(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    delete1(name: string, options?: any): AxiosPromise<void> {
      return ScriptApiFp(configuration)
        .delete1(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update stored script by name
     * @param {string} name
     * @param {ScriptXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    edit(name: string, body?: ScriptXO, options?: any): AxiosPromise<void> {
      return ScriptApiFp(configuration)
        .edit(name, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Read stored script by name
     * @param {string} name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    read1(name: string, options?: any): AxiosPromise<ScriptXO> {
      return ScriptApiFp(configuration)
        .read1(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Run stored script by name
     * @param {string} name
     * @param {string} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    run1(
      name: string,
      body?: string,
      options?: any,
    ): AxiosPromise<ScriptResultXO> {
      return ScriptApiFp(configuration)
        .run1(name, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * ScriptApi - object-oriented interface
 * @export
 * @class ScriptApi
 * @extends {BaseAPI}
 */
export class ScriptApi extends BaseAPI {
  /**
   *
   * @summary Add a new script
   * @param {ScriptXO} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public add(body?: ScriptXO, options?: any) {
    return ScriptApiFp(this.configuration)
      .add(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List all stored scripts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public browse(options?: any) {
    return ScriptApiFp(this.configuration)
      .browse(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete stored script by name
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public delete1(name: string, options?: any) {
    return ScriptApiFp(this.configuration)
      .delete1(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update stored script by name
   * @param {string} name
   * @param {ScriptXO} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public edit(name: string, body?: ScriptXO, options?: any) {
    return ScriptApiFp(this.configuration)
      .edit(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Read stored script by name
   * @param {string} name
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public read1(name: string, options?: any) {
    return ScriptApiFp(this.configuration)
      .read1(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Run stored script by name
   * @param {string} name
   * @param {string} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScriptApi
   */
  public run1(name: string, body?: string, options?: any) {
    return ScriptApiFp(this.configuration)
      .run1(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Search components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search: async (
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/search`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (continuationToken !== undefined) {
        localVarQueryParameter['continuationToken'] = continuationToken
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (timeout !== undefined) {
        localVarQueryParameter['timeout'] = timeout
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      if (md5 !== undefined) {
        localVarQueryParameter['md5'] = md5
      }

      if (sha1 !== undefined) {
        localVarQueryParameter['sha1'] = sha1
      }

      if (sha256 !== undefined) {
        localVarQueryParameter['sha256'] = sha256
      }

      if (sha512 !== undefined) {
        localVarQueryParameter['sha512'] = sha512
      }

      if (prerelease !== undefined) {
        localVarQueryParameter['prerelease'] = prerelease
      }

      if (conanBaseVersion !== undefined) {
        localVarQueryParameter['conan.baseVersion'] = conanBaseVersion
      }

      if (conanChannel !== undefined) {
        localVarQueryParameter['conan.channel'] = conanChannel
      }

      if (dockerImageName !== undefined) {
        localVarQueryParameter['docker.imageName'] = dockerImageName
      }

      if (dockerImageTag !== undefined) {
        localVarQueryParameter['docker.imageTag'] = dockerImageTag
      }

      if (dockerLayerId !== undefined) {
        localVarQueryParameter['docker.layerId'] = dockerLayerId
      }

      if (dockerContentDigest !== undefined) {
        localVarQueryParameter['docker.contentDigest'] = dockerContentDigest
      }

      if (mavenGroupId !== undefined) {
        localVarQueryParameter['maven.groupId'] = mavenGroupId
      }

      if (mavenArtifactId !== undefined) {
        localVarQueryParameter['maven.artifactId'] = mavenArtifactId
      }

      if (mavenBaseVersion !== undefined) {
        localVarQueryParameter['maven.baseVersion'] = mavenBaseVersion
      }

      if (mavenExtension !== undefined) {
        localVarQueryParameter['maven.extension'] = mavenExtension
      }

      if (mavenClassifier !== undefined) {
        localVarQueryParameter['maven.classifier'] = mavenClassifier
      }

      if (npmScope !== undefined) {
        localVarQueryParameter['npm.scope'] = npmScope
      }

      if (nugetId !== undefined) {
        localVarQueryParameter['nuget.id'] = nugetId
      }

      if (nugetTags !== undefined) {
        localVarQueryParameter['nuget.tags'] = nugetTags
      }

      if (p2PluginName !== undefined) {
        localVarQueryParameter['p2.pluginName'] = p2PluginName
      }

      if (pypiClassifiers !== undefined) {
        localVarQueryParameter['pypi.classifiers'] = pypiClassifiers
      }

      if (pypiDescription !== undefined) {
        localVarQueryParameter['pypi.description'] = pypiDescription
      }

      if (pypiKeywords !== undefined) {
        localVarQueryParameter['pypi.keywords'] = pypiKeywords
      }

      if (pypiSummary !== undefined) {
        localVarQueryParameter['pypi.summary'] = pypiSummary
      }

      if (rubygemsDescription !== undefined) {
        localVarQueryParameter['rubygems.description'] = rubygemsDescription
      }

      if (rubygemsPlatform !== undefined) {
        localVarQueryParameter['rubygems.platform'] = rubygemsPlatform
      }

      if (rubygemsSummary !== undefined) {
        localVarQueryParameter['rubygems.summary'] = rubygemsSummary
      }

      if (yumArchitecture !== undefined) {
        localVarQueryParameter['yum.architecture'] = yumArchitecture
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     * Returns a 302 Found with location header field set to download URL. Unless a sort parameter is supplied, the search must return a single asset to receive download URL.
     * @summary Search and download asset
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty and more than 1 result is returned, the request will fail.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndDownloadAssets: async (
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/search/assets/download`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (timeout !== undefined) {
        localVarQueryParameter['timeout'] = timeout
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      if (md5 !== undefined) {
        localVarQueryParameter['md5'] = md5
      }

      if (sha1 !== undefined) {
        localVarQueryParameter['sha1'] = sha1
      }

      if (sha256 !== undefined) {
        localVarQueryParameter['sha256'] = sha256
      }

      if (sha512 !== undefined) {
        localVarQueryParameter['sha512'] = sha512
      }

      if (prerelease !== undefined) {
        localVarQueryParameter['prerelease'] = prerelease
      }

      if (conanBaseVersion !== undefined) {
        localVarQueryParameter['conan.baseVersion'] = conanBaseVersion
      }

      if (conanChannel !== undefined) {
        localVarQueryParameter['conan.channel'] = conanChannel
      }

      if (dockerImageName !== undefined) {
        localVarQueryParameter['docker.imageName'] = dockerImageName
      }

      if (dockerImageTag !== undefined) {
        localVarQueryParameter['docker.imageTag'] = dockerImageTag
      }

      if (dockerLayerId !== undefined) {
        localVarQueryParameter['docker.layerId'] = dockerLayerId
      }

      if (dockerContentDigest !== undefined) {
        localVarQueryParameter['docker.contentDigest'] = dockerContentDigest
      }

      if (mavenGroupId !== undefined) {
        localVarQueryParameter['maven.groupId'] = mavenGroupId
      }

      if (mavenArtifactId !== undefined) {
        localVarQueryParameter['maven.artifactId'] = mavenArtifactId
      }

      if (mavenBaseVersion !== undefined) {
        localVarQueryParameter['maven.baseVersion'] = mavenBaseVersion
      }

      if (mavenExtension !== undefined) {
        localVarQueryParameter['maven.extension'] = mavenExtension
      }

      if (mavenClassifier !== undefined) {
        localVarQueryParameter['maven.classifier'] = mavenClassifier
      }

      if (npmScope !== undefined) {
        localVarQueryParameter['npm.scope'] = npmScope
      }

      if (nugetId !== undefined) {
        localVarQueryParameter['nuget.id'] = nugetId
      }

      if (nugetTags !== undefined) {
        localVarQueryParameter['nuget.tags'] = nugetTags
      }

      if (p2PluginName !== undefined) {
        localVarQueryParameter['p2.pluginName'] = p2PluginName
      }

      if (pypiClassifiers !== undefined) {
        localVarQueryParameter['pypi.classifiers'] = pypiClassifiers
      }

      if (pypiDescription !== undefined) {
        localVarQueryParameter['pypi.description'] = pypiDescription
      }

      if (pypiKeywords !== undefined) {
        localVarQueryParameter['pypi.keywords'] = pypiKeywords
      }

      if (pypiSummary !== undefined) {
        localVarQueryParameter['pypi.summary'] = pypiSummary
      }

      if (rubygemsDescription !== undefined) {
        localVarQueryParameter['rubygems.description'] = rubygemsDescription
      }

      if (rubygemsPlatform !== undefined) {
        localVarQueryParameter['rubygems.platform'] = rubygemsPlatform
      }

      if (rubygemsSummary !== undefined) {
        localVarQueryParameter['rubygems.summary'] = rubygemsSummary
      }

      if (yumArchitecture !== undefined) {
        localVarQueryParameter['yum.architecture'] = yumArchitecture
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Search assets
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAssets: async (
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/search/assets`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (continuationToken !== undefined) {
        localVarQueryParameter['continuationToken'] = continuationToken
      }

      if (sort !== undefined) {
        localVarQueryParameter['sort'] = sort
      }

      if (direction !== undefined) {
        localVarQueryParameter['direction'] = direction
      }

      if (timeout !== undefined) {
        localVarQueryParameter['timeout'] = timeout
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q
      }

      if (repository !== undefined) {
        localVarQueryParameter['repository'] = repository
      }

      if (format !== undefined) {
        localVarQueryParameter['format'] = format
      }

      if (group !== undefined) {
        localVarQueryParameter['group'] = group
      }

      if (name !== undefined) {
        localVarQueryParameter['name'] = name
      }

      if (version !== undefined) {
        localVarQueryParameter['version'] = version
      }

      if (md5 !== undefined) {
        localVarQueryParameter['md5'] = md5
      }

      if (sha1 !== undefined) {
        localVarQueryParameter['sha1'] = sha1
      }

      if (sha256 !== undefined) {
        localVarQueryParameter['sha256'] = sha256
      }

      if (sha512 !== undefined) {
        localVarQueryParameter['sha512'] = sha512
      }

      if (prerelease !== undefined) {
        localVarQueryParameter['prerelease'] = prerelease
      }

      if (conanBaseVersion !== undefined) {
        localVarQueryParameter['conan.baseVersion'] = conanBaseVersion
      }

      if (conanChannel !== undefined) {
        localVarQueryParameter['conan.channel'] = conanChannel
      }

      if (dockerImageName !== undefined) {
        localVarQueryParameter['docker.imageName'] = dockerImageName
      }

      if (dockerImageTag !== undefined) {
        localVarQueryParameter['docker.imageTag'] = dockerImageTag
      }

      if (dockerLayerId !== undefined) {
        localVarQueryParameter['docker.layerId'] = dockerLayerId
      }

      if (dockerContentDigest !== undefined) {
        localVarQueryParameter['docker.contentDigest'] = dockerContentDigest
      }

      if (mavenGroupId !== undefined) {
        localVarQueryParameter['maven.groupId'] = mavenGroupId
      }

      if (mavenArtifactId !== undefined) {
        localVarQueryParameter['maven.artifactId'] = mavenArtifactId
      }

      if (mavenBaseVersion !== undefined) {
        localVarQueryParameter['maven.baseVersion'] = mavenBaseVersion
      }

      if (mavenExtension !== undefined) {
        localVarQueryParameter['maven.extension'] = mavenExtension
      }

      if (mavenClassifier !== undefined) {
        localVarQueryParameter['maven.classifier'] = mavenClassifier
      }

      if (npmScope !== undefined) {
        localVarQueryParameter['npm.scope'] = npmScope
      }

      if (nugetId !== undefined) {
        localVarQueryParameter['nuget.id'] = nugetId
      }

      if (nugetTags !== undefined) {
        localVarQueryParameter['nuget.tags'] = nugetTags
      }

      if (p2PluginName !== undefined) {
        localVarQueryParameter['p2.pluginName'] = p2PluginName
      }

      if (pypiClassifiers !== undefined) {
        localVarQueryParameter['pypi.classifiers'] = pypiClassifiers
      }

      if (pypiDescription !== undefined) {
        localVarQueryParameter['pypi.description'] = pypiDescription
      }

      if (pypiKeywords !== undefined) {
        localVarQueryParameter['pypi.keywords'] = pypiKeywords
      }

      if (pypiSummary !== undefined) {
        localVarQueryParameter['pypi.summary'] = pypiSummary
      }

      if (rubygemsDescription !== undefined) {
        localVarQueryParameter['rubygems.description'] = rubygemsDescription
      }

      if (rubygemsPlatform !== undefined) {
        localVarQueryParameter['rubygems.platform'] = rubygemsPlatform
      }

      if (rubygemsSummary !== undefined) {
        localVarQueryParameter['rubygems.summary'] = rubygemsSummary
      }

      if (yumArchitecture !== undefined) {
        localVarQueryParameter['yum.architecture'] = yumArchitecture
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Search components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async search(
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<PageComponentXO>
    > {
      const localVarAxiosArgs = await SearchApiAxiosParamCreator(
        configuration,
      ).search(
        continuationToken,
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     * Returns a 302 Found with location header field set to download URL. Unless a sort parameter is supplied, the search must return a single asset to receive download URL.
     * @summary Search and download asset
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty and more than 1 result is returned, the request will fail.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAndDownloadAssets(
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SearchApiAxiosParamCreator(
        configuration,
      ).searchAndDownloadAssets(
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Search assets
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async searchAssets(
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageAssetXO>
    > {
      const localVarAxiosArgs = await SearchApiAxiosParamCreator(
        configuration,
      ).searchAssets(
        continuationToken,
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Search components
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    search(
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): AxiosPromise<PageComponentXO> {
      return SearchApiFp(configuration)
        .search(
          continuationToken,
          sort,
          direction,
          timeout,
          q,
          repository,
          format,
          group,
          name,
          version,
          md5,
          sha1,
          sha256,
          sha512,
          prerelease,
          conanBaseVersion,
          conanChannel,
          dockerImageName,
          dockerImageTag,
          dockerLayerId,
          dockerContentDigest,
          mavenGroupId,
          mavenArtifactId,
          mavenBaseVersion,
          mavenExtension,
          mavenClassifier,
          npmScope,
          nugetId,
          nugetTags,
          p2PluginName,
          pypiClassifiers,
          pypiDescription,
          pypiKeywords,
          pypiSummary,
          rubygemsDescription,
          rubygemsPlatform,
          rubygemsSummary,
          yumArchitecture,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     * Returns a 302 Found with location header field set to download URL. Unless a sort parameter is supplied, the search must return a single asset to receive download URL.
     * @summary Search and download asset
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty and more than 1 result is returned, the request will fail.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAndDownloadAssets(
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): AxiosPromise<void> {
      return SearchApiFp(configuration)
        .searchAndDownloadAssets(
          sort,
          direction,
          timeout,
          q,
          repository,
          format,
          group,
          name,
          version,
          md5,
          sha1,
          sha256,
          sha512,
          prerelease,
          conanBaseVersion,
          conanChannel,
          dockerImageName,
          dockerImageTag,
          dockerLayerId,
          dockerContentDigest,
          mavenGroupId,
          mavenArtifactId,
          mavenBaseVersion,
          mavenExtension,
          mavenClassifier,
          npmScope,
          nugetId,
          nugetTags,
          p2PluginName,
          pypiClassifiers,
          pypiDescription,
          pypiKeywords,
          pypiSummary,
          rubygemsDescription,
          rubygemsPlatform,
          rubygemsSummary,
          yumArchitecture,
          options,
        )
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Search assets
     * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
     * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
     * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
     * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
     * @param {string} [q] Query by keyword
     * @param {string} [repository] Repository name
     * @param {string} [format] Query by format
     * @param {string} [group] Component group
     * @param {string} [name] Component name
     * @param {string} [version] Component version
     * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
     * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
     * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
     * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
     * @param {string} [prerelease] Prerelease version flag
     * @param {string} [conanBaseVersion] baseVersion
     * @param {string} [conanChannel] channel
     * @param {string} [dockerImageName] Docker image name
     * @param {string} [dockerImageTag] Docker image tag
     * @param {string} [dockerLayerId] Docker layer ID
     * @param {string} [dockerContentDigest] Docker content digest
     * @param {string} [mavenGroupId] Maven groupId
     * @param {string} [mavenArtifactId] Maven artifactId
     * @param {string} [mavenBaseVersion] Maven base version
     * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
     * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
     * @param {string} [npmScope] npm scope
     * @param {string} [nugetId] NuGet id
     * @param {string} [nugetTags] NuGet tags
     * @param {string} [p2PluginName] p2 plugin name
     * @param {string} [pypiClassifiers] PyPI classifiers
     * @param {string} [pypiDescription] PyPI description
     * @param {string} [pypiKeywords] PyPI keywords
     * @param {string} [pypiSummary] PyPI summary
     * @param {string} [rubygemsDescription] RubyGems description
     * @param {string} [rubygemsPlatform] RubyGems platform
     * @param {string} [rubygemsSummary] RubyGems summary
     * @param {string} [yumArchitecture] Yum architecture
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    searchAssets(
      continuationToken?: string,
      sort?: 'group' | 'name' | 'version' | 'repository',
      direction?: 'asc' | 'desc',
      timeout?: number,
      q?: string,
      repository?: string,
      format?: string,
      group?: string,
      name?: string,
      version?: string,
      md5?: string,
      sha1?: string,
      sha256?: string,
      sha512?: string,
      prerelease?: string,
      conanBaseVersion?: string,
      conanChannel?: string,
      dockerImageName?: string,
      dockerImageTag?: string,
      dockerLayerId?: string,
      dockerContentDigest?: string,
      mavenGroupId?: string,
      mavenArtifactId?: string,
      mavenBaseVersion?: string,
      mavenExtension?: string,
      mavenClassifier?: string,
      npmScope?: string,
      nugetId?: string,
      nugetTags?: string,
      p2PluginName?: string,
      pypiClassifiers?: string,
      pypiDescription?: string,
      pypiKeywords?: string,
      pypiSummary?: string,
      rubygemsDescription?: string,
      rubygemsPlatform?: string,
      rubygemsSummary?: string,
      yumArchitecture?: string,
      options?: any,
    ): AxiosPromise<PageAssetXO> {
      return SearchApiFp(configuration)
        .searchAssets(
          continuationToken,
          sort,
          direction,
          timeout,
          q,
          repository,
          format,
          group,
          name,
          version,
          md5,
          sha1,
          sha256,
          sha512,
          prerelease,
          conanBaseVersion,
          conanChannel,
          dockerImageName,
          dockerImageTag,
          dockerLayerId,
          dockerContentDigest,
          mavenGroupId,
          mavenArtifactId,
          mavenBaseVersion,
          mavenExtension,
          mavenClassifier,
          npmScope,
          nugetId,
          nugetTags,
          p2PluginName,
          pypiClassifiers,
          pypiDescription,
          pypiKeywords,
          pypiSummary,
          rubygemsDescription,
          rubygemsPlatform,
          rubygemsSummary,
          yumArchitecture,
          options,
        )
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
  /**
   *
   * @summary Search components
   * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
   * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
   * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
   * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
   * @param {string} [q] Query by keyword
   * @param {string} [repository] Repository name
   * @param {string} [format] Query by format
   * @param {string} [group] Component group
   * @param {string} [name] Component name
   * @param {string} [version] Component version
   * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
   * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
   * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
   * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
   * @param {string} [prerelease] Prerelease version flag
   * @param {string} [conanBaseVersion] baseVersion
   * @param {string} [conanChannel] channel
   * @param {string} [dockerImageName] Docker image name
   * @param {string} [dockerImageTag] Docker image tag
   * @param {string} [dockerLayerId] Docker layer ID
   * @param {string} [dockerContentDigest] Docker content digest
   * @param {string} [mavenGroupId] Maven groupId
   * @param {string} [mavenArtifactId] Maven artifactId
   * @param {string} [mavenBaseVersion] Maven base version
   * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
   * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
   * @param {string} [npmScope] npm scope
   * @param {string} [nugetId] NuGet id
   * @param {string} [nugetTags] NuGet tags
   * @param {string} [p2PluginName] p2 plugin name
   * @param {string} [pypiClassifiers] PyPI classifiers
   * @param {string} [pypiDescription] PyPI description
   * @param {string} [pypiKeywords] PyPI keywords
   * @param {string} [pypiSummary] PyPI summary
   * @param {string} [rubygemsDescription] RubyGems description
   * @param {string} [rubygemsPlatform] RubyGems platform
   * @param {string} [rubygemsSummary] RubyGems summary
   * @param {string} [yumArchitecture] Yum architecture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public search(
    continuationToken?: string,
    sort?: 'group' | 'name' | 'version' | 'repository',
    direction?: 'asc' | 'desc',
    timeout?: number,
    q?: string,
    repository?: string,
    format?: string,
    group?: string,
    name?: string,
    version?: string,
    md5?: string,
    sha1?: string,
    sha256?: string,
    sha512?: string,
    prerelease?: string,
    conanBaseVersion?: string,
    conanChannel?: string,
    dockerImageName?: string,
    dockerImageTag?: string,
    dockerLayerId?: string,
    dockerContentDigest?: string,
    mavenGroupId?: string,
    mavenArtifactId?: string,
    mavenBaseVersion?: string,
    mavenExtension?: string,
    mavenClassifier?: string,
    npmScope?: string,
    nugetId?: string,
    nugetTags?: string,
    p2PluginName?: string,
    pypiClassifiers?: string,
    pypiDescription?: string,
    pypiKeywords?: string,
    pypiSummary?: string,
    rubygemsDescription?: string,
    rubygemsPlatform?: string,
    rubygemsSummary?: string,
    yumArchitecture?: string,
    options?: any,
  ) {
    return SearchApiFp(this.configuration)
      .search(
        continuationToken,
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   * Returns a 302 Found with location header field set to download URL. Unless a sort parameter is supplied, the search must return a single asset to receive download URL.
   * @summary Search and download asset
   * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty and more than 1 result is returned, the request will fail.
   * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
   * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
   * @param {string} [q] Query by keyword
   * @param {string} [repository] Repository name
   * @param {string} [format] Query by format
   * @param {string} [group] Component group
   * @param {string} [name] Component name
   * @param {string} [version] Component version
   * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
   * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
   * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
   * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
   * @param {string} [prerelease] Prerelease version flag
   * @param {string} [conanBaseVersion] baseVersion
   * @param {string} [conanChannel] channel
   * @param {string} [dockerImageName] Docker image name
   * @param {string} [dockerImageTag] Docker image tag
   * @param {string} [dockerLayerId] Docker layer ID
   * @param {string} [dockerContentDigest] Docker content digest
   * @param {string} [mavenGroupId] Maven groupId
   * @param {string} [mavenArtifactId] Maven artifactId
   * @param {string} [mavenBaseVersion] Maven base version
   * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
   * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
   * @param {string} [npmScope] npm scope
   * @param {string} [nugetId] NuGet id
   * @param {string} [nugetTags] NuGet tags
   * @param {string} [p2PluginName] p2 plugin name
   * @param {string} [pypiClassifiers] PyPI classifiers
   * @param {string} [pypiDescription] PyPI description
   * @param {string} [pypiKeywords] PyPI keywords
   * @param {string} [pypiSummary] PyPI summary
   * @param {string} [rubygemsDescription] RubyGems description
   * @param {string} [rubygemsPlatform] RubyGems platform
   * @param {string} [rubygemsSummary] RubyGems summary
   * @param {string} [yumArchitecture] Yum architecture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchAndDownloadAssets(
    sort?: 'group' | 'name' | 'version' | 'repository',
    direction?: 'asc' | 'desc',
    timeout?: number,
    q?: string,
    repository?: string,
    format?: string,
    group?: string,
    name?: string,
    version?: string,
    md5?: string,
    sha1?: string,
    sha256?: string,
    sha512?: string,
    prerelease?: string,
    conanBaseVersion?: string,
    conanChannel?: string,
    dockerImageName?: string,
    dockerImageTag?: string,
    dockerLayerId?: string,
    dockerContentDigest?: string,
    mavenGroupId?: string,
    mavenArtifactId?: string,
    mavenBaseVersion?: string,
    mavenExtension?: string,
    mavenClassifier?: string,
    npmScope?: string,
    nugetId?: string,
    nugetTags?: string,
    p2PluginName?: string,
    pypiClassifiers?: string,
    pypiDescription?: string,
    pypiKeywords?: string,
    pypiSummary?: string,
    rubygemsDescription?: string,
    rubygemsPlatform?: string,
    rubygemsSummary?: string,
    yumArchitecture?: string,
    options?: any,
  ) {
    return SearchApiFp(this.configuration)
      .searchAndDownloadAssets(
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Search assets
   * @param {string} [continuationToken] A token returned by a prior request. If present, the next page of results are returned
   * @param {'group' | 'name' | 'version' | 'repository'} [sort] The field to sort the results against, if left empty, a sort based on match weight will be used.
   * @param {'asc' | 'desc'} [direction] The direction to sort records in, defaults to ascending (\&#39;asc\&#39;) for all sort fields, except version, which defaults to descending (\&#39;desc\&#39;)
   * @param {number} [timeout] How long to wait for search results in seconds. If this value is not provided, the system default timeout will be used.
   * @param {string} [q] Query by keyword
   * @param {string} [repository] Repository name
   * @param {string} [format] Query by format
   * @param {string} [group] Component group
   * @param {string} [name] Component name
   * @param {string} [version] Component version
   * @param {string} [md5] Specific MD5 hash of component\&#39;s asset
   * @param {string} [sha1] Specific SHA-1 hash of component\&#39;s asset
   * @param {string} [sha256] Specific SHA-256 hash of component\&#39;s asset
   * @param {string} [sha512] Specific SHA-512 hash of component\&#39;s asset
   * @param {string} [prerelease] Prerelease version flag
   * @param {string} [conanBaseVersion] baseVersion
   * @param {string} [conanChannel] channel
   * @param {string} [dockerImageName] Docker image name
   * @param {string} [dockerImageTag] Docker image tag
   * @param {string} [dockerLayerId] Docker layer ID
   * @param {string} [dockerContentDigest] Docker content digest
   * @param {string} [mavenGroupId] Maven groupId
   * @param {string} [mavenArtifactId] Maven artifactId
   * @param {string} [mavenBaseVersion] Maven base version
   * @param {string} [mavenExtension] Maven extension of component\&#39;s asset
   * @param {string} [mavenClassifier] Maven classifier of component\&#39;s asset
   * @param {string} [npmScope] npm scope
   * @param {string} [nugetId] NuGet id
   * @param {string} [nugetTags] NuGet tags
   * @param {string} [p2PluginName] p2 plugin name
   * @param {string} [pypiClassifiers] PyPI classifiers
   * @param {string} [pypiDescription] PyPI description
   * @param {string} [pypiKeywords] PyPI keywords
   * @param {string} [pypiSummary] PyPI summary
   * @param {string} [rubygemsDescription] RubyGems description
   * @param {string} [rubygemsPlatform] RubyGems platform
   * @param {string} [rubygemsSummary] RubyGems summary
   * @param {string} [yumArchitecture] Yum architecture
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SearchApi
   */
  public searchAssets(
    continuationToken?: string,
    sort?: 'group' | 'name' | 'version' | 'repository',
    direction?: 'asc' | 'desc',
    timeout?: number,
    q?: string,
    repository?: string,
    format?: string,
    group?: string,
    name?: string,
    version?: string,
    md5?: string,
    sha1?: string,
    sha256?: string,
    sha512?: string,
    prerelease?: string,
    conanBaseVersion?: string,
    conanChannel?: string,
    dockerImageName?: string,
    dockerImageTag?: string,
    dockerLayerId?: string,
    dockerContentDigest?: string,
    mavenGroupId?: string,
    mavenArtifactId?: string,
    mavenBaseVersion?: string,
    mavenExtension?: string,
    mavenClassifier?: string,
    npmScope?: string,
    nugetId?: string,
    nugetTags?: string,
    p2PluginName?: string,
    pypiClassifiers?: string,
    pypiDescription?: string,
    pypiKeywords?: string,
    pypiSummary?: string,
    rubygemsDescription?: string,
    rubygemsPlatform?: string,
    rubygemsSummary?: string,
    yumArchitecture?: string,
    options?: any,
  ) {
    return SearchApiFp(this.configuration)
      .searchAssets(
        continuationToken,
        sort,
        direction,
        timeout,
        q,
        repository,
        format,
        group,
        name,
        version,
        md5,
        sha1,
        sha256,
        sha512,
        prerelease,
        conanBaseVersion,
        conanChannel,
        dockerImageName,
        dockerImageTag,
        dockerLayerId,
        dockerContentDigest,
        mavenGroupId,
        mavenArtifactId,
        mavenBaseVersion,
        mavenExtension,
        mavenClassifier,
        npmScope,
        nugetId,
        nugetTags,
        p2PluginName,
        pypiClassifiers,
        pypiDescription,
        pypiKeywords,
        pypiSummary,
        rubygemsDescription,
        rubygemsPlatform,
        rubygemsSummary,
        yumArchitecture,
        options,
      )
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityCertificatesApi - axios parameter creator
 * @export
 */
export const SecurityCertificatesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Add a certificate to the trust store.
     * @param {string} [body] The certificate to add encoded in PEM format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCertificate: async (
      body?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/ssl/truststore`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Retrieve a list of certificates added to the trust store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrustStoreCertificates: async (
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/ssl/truststore`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Remove a certificate in the trust store.
     * @param {string} id The id of the certificate that should be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCertificate: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling removeCertificate.',
        )
      }
      const localVarPath = `/v1/security/ssl/truststore/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Helper method to retrieve certificate details from a remote system.
     * @param {string} host The remote system\&#39;s host name
     * @param {number} [port] The port on the remote system to connect to
     * @param {string} [protocolHint] An optional hint of the protocol to try for the connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveCertificate: async (
      host: string,
      port?: number,
      protocolHint?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'host' is not null or undefined
      if (host === null || host === undefined) {
        throw new RequiredError(
          'host',
          'Required parameter host was null or undefined when calling retrieveCertificate.',
        )
      }
      const localVarPath = `/v1/security/ssl`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (host !== undefined) {
        localVarQueryParameter['host'] = host
      }

      if (port !== undefined) {
        localVarQueryParameter['port'] = port
      }

      if (protocolHint !== undefined) {
        localVarQueryParameter['protocolHint'] = protocolHint
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityCertificatesApi - functional programming interface
 * @export
 */
export const SecurityCertificatesApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Add a certificate to the trust store.
     * @param {string} [body] The certificate to add encoded in PEM format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addCertificate(
      body?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCertificate>
    > {
      const localVarAxiosArgs = await SecurityCertificatesApiAxiosParamCreator(
        configuration,
      ).addCertificate(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Retrieve a list of certificates added to the trust store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTrustStoreCertificates(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiCertificate>>
    > {
      const localVarAxiosArgs = await SecurityCertificatesApiAxiosParamCreator(
        configuration,
      ).getTrustStoreCertificates(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Remove a certificate in the trust store.
     * @param {string} id The id of the certificate that should be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async removeCertificate(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityCertificatesApiAxiosParamCreator(
        configuration,
      ).removeCertificate(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Helper method to retrieve certificate details from a remote system.
     * @param {string} host The remote system\&#39;s host name
     * @param {number} [port] The port on the remote system to connect to
     * @param {string} [protocolHint] An optional hint of the protocol to try for the connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async retrieveCertificate(
      host: string,
      port?: number,
      protocolHint?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiCertificate>
    > {
      const localVarAxiosArgs = await SecurityCertificatesApiAxiosParamCreator(
        configuration,
      ).retrieveCertificate(host, port, protocolHint, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityCertificatesApi - factory interface
 * @export
 */
export const SecurityCertificatesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Add a certificate to the trust store.
     * @param {string} [body] The certificate to add encoded in PEM format
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addCertificate(body?: string, options?: any): AxiosPromise<ApiCertificate> {
      return SecurityCertificatesApiFp(configuration)
        .addCertificate(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Retrieve a list of certificates added to the trust store.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTrustStoreCertificates(
      options?: any,
    ): AxiosPromise<Array<ApiCertificate>> {
      return SecurityCertificatesApiFp(configuration)
        .getTrustStoreCertificates(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Remove a certificate in the trust store.
     * @param {string} id The id of the certificate that should be removed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeCertificate(id: string, options?: any): AxiosPromise<void> {
      return SecurityCertificatesApiFp(configuration)
        .removeCertificate(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Helper method to retrieve certificate details from a remote system.
     * @param {string} host The remote system\&#39;s host name
     * @param {number} [port] The port on the remote system to connect to
     * @param {string} [protocolHint] An optional hint of the protocol to try for the connection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    retrieveCertificate(
      host: string,
      port?: number,
      protocolHint?: string,
      options?: any,
    ): AxiosPromise<ApiCertificate> {
      return SecurityCertificatesApiFp(configuration)
        .retrieveCertificate(host, port, protocolHint, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityCertificatesApi - object-oriented interface
 * @export
 * @class SecurityCertificatesApi
 * @extends {BaseAPI}
 */
export class SecurityCertificatesApi extends BaseAPI {
  /**
   *
   * @summary Add a certificate to the trust store.
   * @param {string} [body] The certificate to add encoded in PEM format
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityCertificatesApi
   */
  public addCertificate(body?: string, options?: any) {
    return SecurityCertificatesApiFp(this.configuration)
      .addCertificate(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Retrieve a list of certificates added to the trust store.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityCertificatesApi
   */
  public getTrustStoreCertificates(options?: any) {
    return SecurityCertificatesApiFp(this.configuration)
      .getTrustStoreCertificates(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Remove a certificate in the trust store.
   * @param {string} id The id of the certificate that should be removed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityCertificatesApi
   */
  public removeCertificate(id: string, options?: any) {
    return SecurityCertificatesApiFp(this.configuration)
      .removeCertificate(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Helper method to retrieve certificate details from a remote system.
   * @param {string} host The remote system\&#39;s host name
   * @param {number} [port] The port on the remote system to connect to
   * @param {string} [protocolHint] An optional hint of the protocol to try for the connection
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityCertificatesApi
   */
  public retrieveCertificate(
    host: string,
    port?: number,
    protocolHint?: string,
    options?: any,
  ) {
    return SecurityCertificatesApiFp(this.configuration)
      .retrieveCertificate(host, port, protocolHint, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementApi - axios parameter creator
 * @export
 */
export const SecurityManagementApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Retrieve a list of the available user sources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSources: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/user-sources`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementApi - functional programming interface
 * @export
 */
export const SecurityManagementApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Retrieve a list of the available user sources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUserSources(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiUserSource>>
    > {
      const localVarAxiosArgs = await SecurityManagementApiAxiosParamCreator(
        configuration,
      ).getUserSources(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementApi - factory interface
 * @export
 */
export const SecurityManagementApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Retrieve a list of the available user sources.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUserSources(options?: any): AxiosPromise<Array<ApiUserSource>> {
      return SecurityManagementApiFp(configuration)
        .getUserSources(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementApi - object-oriented interface
 * @export
 * @class SecurityManagementApi
 * @extends {BaseAPI}
 */
export class SecurityManagementApi extends BaseAPI {
  /**
   *
   * @summary Retrieve a list of the available user sources.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementApi
   */
  public getUserSources(options?: any) {
    return SecurityManagementApiFp(this.configuration)
      .getUserSources(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementAnonymousAccessApi - axios parameter creator
 * @export
 */
export const SecurityManagementAnonymousAccessApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get Anonymous Access settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    read: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/anonymous`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update Anonymous Access settings
     * @param {AnonymousAccessSettingsXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: async (
      body?: AnonymousAccessSettingsXO,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/anonymous`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementAnonymousAccessApi - functional programming interface
 * @export
 */
export const SecurityManagementAnonymousAccessApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get Anonymous Access settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async read(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AnonymousAccessSettingsXO>
    > {
      const localVarAxiosArgs = await SecurityManagementAnonymousAccessApiAxiosParamCreator(
        configuration,
      ).read(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update Anonymous Access settings
     * @param {AnonymousAccessSettingsXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update(
      body?: AnonymousAccessSettingsXO,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<AnonymousAccessSettingsXO>
    > {
      const localVarAxiosArgs = await SecurityManagementAnonymousAccessApiAxiosParamCreator(
        configuration,
      ).update(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementAnonymousAccessApi - factory interface
 * @export
 */
export const SecurityManagementAnonymousAccessApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get Anonymous Access settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    read(options?: any): AxiosPromise<AnonymousAccessSettingsXO> {
      return SecurityManagementAnonymousAccessApiFp(configuration)
        .read(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update Anonymous Access settings
     * @param {AnonymousAccessSettingsXO} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(
      body?: AnonymousAccessSettingsXO,
      options?: any,
    ): AxiosPromise<AnonymousAccessSettingsXO> {
      return SecurityManagementAnonymousAccessApiFp(configuration)
        .update(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementAnonymousAccessApi - object-oriented interface
 * @export
 * @class SecurityManagementAnonymousAccessApi
 * @extends {BaseAPI}
 */
export class SecurityManagementAnonymousAccessApi extends BaseAPI {
  /**
   *
   * @summary Get Anonymous Access settings
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementAnonymousAccessApi
   */
  public read(options?: any) {
    return SecurityManagementAnonymousAccessApiFp(this.configuration)
      .read(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update Anonymous Access settings
   * @param {AnonymousAccessSettingsXO} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementAnonymousAccessApi
   */
  public update(body?: AnonymousAccessSettingsXO, options?: any) {
    return SecurityManagementAnonymousAccessApiFp(this.configuration)
      .update(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementLDAPApi - axios parameter creator
 * @export
 */
export const SecurityManagementLDAPApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change LDAP server order
     * @param {Array<string>} [body] Ordered list of LDAP server names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeOrder: async (
      body?: Array<string>,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/ldap/change-order`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create LDAP server
     * @param {CreateLdapServerXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLdapServer: async (
      body?: CreateLdapServerXo,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/ldap`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete LDAP server
     * @param {string} name Name of the LDAP server to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLdapServer: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling deleteLdapServer.',
        )
      }
      const localVarPath = `/v1/security/ldap/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get LDAP server
     * @param {string} name Name of the LDAP server to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLdapServer: async (
      name: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling getLdapServer.',
        )
      }
      const localVarPath = `/v1/security/ldap/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List LDAP servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLdapServers: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/ldap`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update LDAP server
     * @param {string} name Name of the LDAP server to update
     * @param {UpdateLdapServerXo} [body] Updated values of LDAP server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLdapServer: async (
      name: string,
      body?: UpdateLdapServerXo,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'name' is not null or undefined
      if (name === null || name === undefined) {
        throw new RequiredError(
          'name',
          'Required parameter name was null or undefined when calling updateLdapServer.',
        )
      }
      const localVarPath = `/v1/security/ldap/{name}`.replace(
        `{${'name'}}`,
        encodeURIComponent(String(name)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementLDAPApi - functional programming interface
 * @export
 */
export const SecurityManagementLDAPApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change LDAP server order
     * @param {Array<string>} [body] Ordered list of LDAP server names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changeOrder(
      body?: Array<string>,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).changeOrder(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create LDAP server
     * @param {CreateLdapServerXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createLdapServer(
      body?: CreateLdapServerXo,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).createLdapServer(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete LDAP server
     * @param {string} name Name of the LDAP server to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteLdapServer(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).deleteLdapServer(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get LDAP server
     * @param {string} name Name of the LDAP server to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLdapServer(
      name: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).getLdapServer(name, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List LDAP servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getLdapServers(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).getLdapServers(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update LDAP server
     * @param {string} name Name of the LDAP server to update
     * @param {UpdateLdapServerXo} [body] Updated values of LDAP server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateLdapServer(
      name: string,
      body?: UpdateLdapServerXo,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementLDAPApiAxiosParamCreator(
        configuration,
      ).updateLdapServer(name, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementLDAPApi - factory interface
 * @export
 */
export const SecurityManagementLDAPApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Change LDAP server order
     * @param {Array<string>} [body] Ordered list of LDAP server names
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changeOrder(body?: Array<string>, options?: any): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .changeOrder(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create LDAP server
     * @param {CreateLdapServerXo} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createLdapServer(
      body?: CreateLdapServerXo,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .createLdapServer(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete LDAP server
     * @param {string} name Name of the LDAP server to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteLdapServer(name: string, options?: any): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .deleteLdapServer(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get LDAP server
     * @param {string} name Name of the LDAP server to retrieve
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLdapServer(name: string, options?: any): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .getLdapServer(name, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List LDAP servers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getLdapServers(options?: any): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .getLdapServers(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update LDAP server
     * @param {string} name Name of the LDAP server to update
     * @param {UpdateLdapServerXo} [body] Updated values of LDAP server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateLdapServer(
      name: string,
      body?: UpdateLdapServerXo,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementLDAPApiFp(configuration)
        .updateLdapServer(name, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementLDAPApi - object-oriented interface
 * @export
 * @class SecurityManagementLDAPApi
 * @extends {BaseAPI}
 */
export class SecurityManagementLDAPApi extends BaseAPI {
  /**
   *
   * @summary Change LDAP server order
   * @param {Array<string>} [body] Ordered list of LDAP server names
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public changeOrder(body?: Array<string>, options?: any) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .changeOrder(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create LDAP server
   * @param {CreateLdapServerXo} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public createLdapServer(body?: CreateLdapServerXo, options?: any) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .createLdapServer(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete LDAP server
   * @param {string} name Name of the LDAP server to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public deleteLdapServer(name: string, options?: any) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .deleteLdapServer(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get LDAP server
   * @param {string} name Name of the LDAP server to retrieve
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public getLdapServer(name: string, options?: any) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .getLdapServer(name, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List LDAP servers
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public getLdapServers(options?: any) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .getLdapServers(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update LDAP server
   * @param {string} name Name of the LDAP server to update
   * @param {UpdateLdapServerXo} [body] Updated values of LDAP server
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementLDAPApi
   */
  public updateLdapServer(
    name: string,
    body?: UpdateLdapServerXo,
    options?: any,
  ) {
    return SecurityManagementLDAPApiFp(this.configuration)
      .updateLdapServer(name, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementPrivilegesApi - axios parameter creator
 * @export
 */
export const SecurityManagementPrivilegesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a wildcard type privilege.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege: async (
      body?: ApiPrivilegeWildcardRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/wildcard`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create an application type privilege.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege1: async (
      body?: ApiPrivilegeApplicationRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/application`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a repository content selector type privilege.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege2: async (
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/repository-content-selector`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a repository admin type privilege.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege3: async (
      body?: ApiPrivilegeRepositoryAdminRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/repository-admin`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a repository view type privilege.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege4: async (
      body?: ApiPrivilegeRepositoryViewRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/repository-view`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a script type privilege.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege5: async (
      body?: ApiPrivilegeScriptRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges/script`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a privilege by id.
     * @param {string} privilegeId The id of the privilege to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivilege: async (
      privilegeId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling deletePrivilege.',
        )
      }
      const localVarPath = `/v1/security/privileges/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Retrieve a privilege by id.
     * @param {string} privilegeId The id of the privilege to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivilege: async (
      privilegeId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling getPrivilege.',
        )
      }
      const localVarPath = `/v1/security/privileges/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Retrieve a list of privileges.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivileges: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/privileges`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a wildcard type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege: async (
      privilegeId: string,
      body?: ApiPrivilegeWildcardRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege.',
        )
      }
      const localVarPath = `/v1/security/privileges/wildcard/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update an application type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege1: async (
      privilegeId: string,
      body?: ApiPrivilegeApplicationRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege1.',
        )
      }
      const localVarPath = `/v1/security/privileges/application/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a repository view type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege2: async (
      privilegeId: string,
      body?: ApiPrivilegeRepositoryViewRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege2.',
        )
      }
      const localVarPath = `/v1/security/privileges/repository-view/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a repository content selector type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege3: async (
      privilegeId: string,
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege3.',
        )
      }
      const localVarPath = `/v1/security/privileges/repository-content-selector/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a repository admin type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege4: async (
      privilegeId: string,
      body?: ApiPrivilegeRepositoryAdminRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege4.',
        )
      }
      const localVarPath = `/v1/security/privileges/repository-admin/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update a script type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege5: async (
      privilegeId: string,
      body?: ApiPrivilegeScriptRequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'privilegeId' is not null or undefined
      if (privilegeId === null || privilegeId === undefined) {
        throw new RequiredError(
          'privilegeId',
          'Required parameter privilegeId was null or undefined when calling updatePrivilege5.',
        )
      }
      const localVarPath = `/v1/security/privileges/script/{privilegeId}`.replace(
        `{${'privilegeId'}}`,
        encodeURIComponent(String(privilegeId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementPrivilegesApi - functional programming interface
 * @export
 */
export const SecurityManagementPrivilegesApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Create a wildcard type privilege.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege(
      body?: ApiPrivilegeWildcardRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create an application type privilege.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege1(
      body?: ApiPrivilegeApplicationRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege1(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a repository content selector type privilege.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege2(
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege2(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a repository admin type privilege.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege3(
      body?: ApiPrivilegeRepositoryAdminRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege3(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a repository view type privilege.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege4(
      body?: ApiPrivilegeRepositoryViewRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege4(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a script type privilege.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createPrivilege5(
      body?: ApiPrivilegeScriptRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).createPrivilege5(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete a privilege by id.
     * @param {string} privilegeId The id of the privilege to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deletePrivilege(
      privilegeId: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).deletePrivilege(privilegeId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Retrieve a privilege by id.
     * @param {string} privilegeId The id of the privilege to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivilege(
      privilegeId: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiPrivilege>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).getPrivilege(privilegeId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Retrieve a list of privileges.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getPrivileges(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<ApiPrivilege>>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).getPrivileges(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a wildcard type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege(
      privilegeId: string,
      body?: ApiPrivilegeWildcardRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update an application type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege1(
      privilegeId: string,
      body?: ApiPrivilegeApplicationRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege1(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a repository view type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege2(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryViewRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege2(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a repository content selector type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege3(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege3(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a repository admin type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege4(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryAdminRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege4(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update a script type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updatePrivilege5(
      privilegeId: string,
      body?: ApiPrivilegeScriptRequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementPrivilegesApiAxiosParamCreator(
        configuration,
      ).updatePrivilege5(privilegeId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementPrivilegesApi - factory interface
 * @export
 */
export const SecurityManagementPrivilegesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Create a wildcard type privilege.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege(
      body?: ApiPrivilegeWildcardRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create an application type privilege.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege1(
      body?: ApiPrivilegeApplicationRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege1(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a repository content selector type privilege.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege2(
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege2(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a repository admin type privilege.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege3(
      body?: ApiPrivilegeRepositoryAdminRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege3(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a repository view type privilege.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege4(
      body?: ApiPrivilegeRepositoryViewRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege4(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a script type privilege.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createPrivilege5(
      body?: ApiPrivilegeScriptRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .createPrivilege5(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a privilege by id.
     * @param {string} privilegeId The id of the privilege to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deletePrivilege(privilegeId: string, options?: any): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .deletePrivilege(privilegeId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Retrieve a privilege by id.
     * @param {string} privilegeId The id of the privilege to retrieve.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivilege(
      privilegeId: string,
      options?: any,
    ): AxiosPromise<ApiPrivilege> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .getPrivilege(privilegeId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Retrieve a list of privileges.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getPrivileges(options?: any): AxiosPromise<Array<ApiPrivilege>> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .getPrivileges(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a wildcard type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeWildcardRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege(
      privilegeId: string,
      body?: ApiPrivilegeWildcardRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update an application type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeApplicationRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege1(
      privilegeId: string,
      body?: ApiPrivilegeApplicationRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege1(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a repository view type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege2(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryViewRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege2(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a repository content selector type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege3(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryContentSelectorRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege3(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a repository admin type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege4(
      privilegeId: string,
      body?: ApiPrivilegeRepositoryAdminRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege4(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update a script type privilege.
     * @param {string} privilegeId The id of the privilege to update.
     * @param {ApiPrivilegeScriptRequest} [body] The privilege to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updatePrivilege5(
      privilegeId: string,
      body?: ApiPrivilegeScriptRequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementPrivilegesApiFp(configuration)
        .updatePrivilege5(privilegeId, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementPrivilegesApi - object-oriented interface
 * @export
 * @class SecurityManagementPrivilegesApi
 * @extends {BaseAPI}
 */
export class SecurityManagementPrivilegesApi extends BaseAPI {
  /**
   *
   * @summary Create a wildcard type privilege.
   * @param {ApiPrivilegeWildcardRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege(body?: ApiPrivilegeWildcardRequest, options?: any) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create an application type privilege.
   * @param {ApiPrivilegeApplicationRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege1(
    body?: ApiPrivilegeApplicationRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege1(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a repository content selector type privilege.
   * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege2(
    body?: ApiPrivilegeRepositoryContentSelectorRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege2(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a repository admin type privilege.
   * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege3(
    body?: ApiPrivilegeRepositoryAdminRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege3(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a repository view type privilege.
   * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege4(
    body?: ApiPrivilegeRepositoryViewRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege4(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a script type privilege.
   * @param {ApiPrivilegeScriptRequest} [body] The privilege to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public createPrivilege5(body?: ApiPrivilegeScriptRequest, options?: any) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .createPrivilege5(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a privilege by id.
   * @param {string} privilegeId The id of the privilege to delete.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public deletePrivilege(privilegeId: string, options?: any) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .deletePrivilege(privilegeId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Retrieve a privilege by id.
   * @param {string} privilegeId The id of the privilege to retrieve.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public getPrivilege(privilegeId: string, options?: any) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .getPrivilege(privilegeId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Retrieve a list of privileges.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public getPrivileges(options?: any) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .getPrivileges(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a wildcard type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeWildcardRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege(
    privilegeId: string,
    body?: ApiPrivilegeWildcardRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update an application type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeApplicationRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege1(
    privilegeId: string,
    body?: ApiPrivilegeApplicationRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege1(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a repository view type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeRepositoryViewRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege2(
    privilegeId: string,
    body?: ApiPrivilegeRepositoryViewRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege2(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a repository content selector type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeRepositoryContentSelectorRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege3(
    privilegeId: string,
    body?: ApiPrivilegeRepositoryContentSelectorRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege3(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a repository admin type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeRepositoryAdminRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege4(
    privilegeId: string,
    body?: ApiPrivilegeRepositoryAdminRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege4(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update a script type privilege.
   * @param {string} privilegeId The id of the privilege to update.
   * @param {ApiPrivilegeScriptRequest} [body] The privilege to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementPrivilegesApi
   */
  public updatePrivilege5(
    privilegeId: string,
    body?: ApiPrivilegeScriptRequest,
    options?: any,
  ) {
    return SecurityManagementPrivilegesApiFp(this.configuration)
      .updatePrivilege5(privilegeId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementRealmsApi - axios parameter creator
 * @export
 */
export const SecurityManagementRealmsApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary List the active realm IDs in order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveRealms: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/realms/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List the available realms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRealms: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/realms/available`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Set the active security realms in the order they should be used
     * @param {Array<string>} [body] The realm IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActiveRealms: async (
      body?: Array<string>,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/realms/active`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementRealmsApi - functional programming interface
 * @export
 */
export const SecurityManagementRealmsApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary List the active realm IDs in order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getActiveRealms(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>
    > {
      const localVarAxiosArgs = await SecurityManagementRealmsApiAxiosParamCreator(
        configuration,
      ).getActiveRealms(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List the available realms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRealms(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RealmApiXO>>
    > {
      const localVarAxiosArgs = await SecurityManagementRealmsApiAxiosParamCreator(
        configuration,
      ).getRealms(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Set the active security realms in the order they should be used
     * @param {Array<string>} [body] The realm IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async setActiveRealms(
      body?: Array<string>,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementRealmsApiAxiosParamCreator(
        configuration,
      ).setActiveRealms(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementRealmsApi - factory interface
 * @export
 */
export const SecurityManagementRealmsApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary List the active realm IDs in order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getActiveRealms(options?: any): AxiosPromise<Array<string>> {
      return SecurityManagementRealmsApiFp(configuration)
        .getActiveRealms(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List the available realms
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRealms(options?: any): AxiosPromise<Array<RealmApiXO>> {
      return SecurityManagementRealmsApiFp(configuration)
        .getRealms(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Set the active security realms in the order they should be used
     * @param {Array<string>} [body] The realm IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    setActiveRealms(body?: Array<string>, options?: any): AxiosPromise<void> {
      return SecurityManagementRealmsApiFp(configuration)
        .setActiveRealms(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementRealmsApi - object-oriented interface
 * @export
 * @class SecurityManagementRealmsApi
 * @extends {BaseAPI}
 */
export class SecurityManagementRealmsApi extends BaseAPI {
  /**
   *
   * @summary List the active realm IDs in order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRealmsApi
   */
  public getActiveRealms(options?: any) {
    return SecurityManagementRealmsApiFp(this.configuration)
      .getActiveRealms(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List the available realms
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRealmsApi
   */
  public getRealms(options?: any) {
    return SecurityManagementRealmsApiFp(this.configuration)
      .getRealms(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Set the active security realms in the order they should be used
   * @param {Array<string>} [body] The realm IDs
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRealmsApi
   */
  public setActiveRealms(body?: Array<string>, options?: any) {
    return SecurityManagementRealmsApiFp(this.configuration)
      .setActiveRealms(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementRolesApi - axios parameter creator
 * @export
 */
export const SecurityManagementRolesApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete role
     * @param {string} id The id of the role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling _delete.',
        )
      }
      const localVarPath = `/v1/security/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create role
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: async (
      body: RoleXORequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling create.',
        )
      }
      const localVarPath = `/v1/security/roles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Get role
     * @param {string} id The id of the role to get
     * @param {string} [source] The id of the user source to filter the roles by. Available sources can be fetched using the \&#39;User Sources\&#39; endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole: async (
      id: string,
      source?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getRole.',
        )
      }
      const localVarPath = `/v1/security/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List roles
     * @param {string} [source] The id of the user source to filter the roles by, if supplied. Otherwise roles from all user sources will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles: async (
      source?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/roles`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update role
     * @param {string} id The id of the role to update
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update1: async (
      id: string,
      body: RoleXORequest,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling update1.',
        )
      }
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling update1.',
        )
      }
      const localVarPath = `/v1/security/roles/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementRolesApi - functional programming interface
 * @export
 */
export const SecurityManagementRolesApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Delete role
     * @param {string} id The id of the role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async _delete(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementRolesApiAxiosParamCreator(
        configuration,
      )._delete(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create role
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async create(
      body: RoleXORequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleXOResponse>
    > {
      const localVarAxiosArgs = await SecurityManagementRolesApiAxiosParamCreator(
        configuration,
      ).create(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Get role
     * @param {string} id The id of the role to get
     * @param {string} [source] The id of the user source to filter the roles by. Available sources can be fetched using the \&#39;User Sources\&#39; endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRole(
      id: string,
      source?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleXOResponse>
    > {
      const localVarAxiosArgs = await SecurityManagementRolesApiAxiosParamCreator(
        configuration,
      ).getRole(id, source, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List roles
     * @param {string} [source] The id of the user source to filter the roles by, if supplied. Otherwise roles from all user sources will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getRoles(
      source?: string,
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<Array<RoleXOResponse>>
    > {
      const localVarAxiosArgs = await SecurityManagementRolesApiAxiosParamCreator(
        configuration,
      ).getRoles(source, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update role
     * @param {string} id The id of the role to update
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async update1(
      id: string,
      body: RoleXORequest,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementRolesApiAxiosParamCreator(
        configuration,
      ).update1(id, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementRolesApi - factory interface
 * @export
 */
export const SecurityManagementRolesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Delete role
     * @param {string} id The id of the role to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    _delete(id: string, options?: any): AxiosPromise<void> {
      return SecurityManagementRolesApiFp(configuration)
        ._delete(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create role
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(body: RoleXORequest, options?: any): AxiosPromise<RoleXOResponse> {
      return SecurityManagementRolesApiFp(configuration)
        .create(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Get role
     * @param {string} id The id of the role to get
     * @param {string} [source] The id of the user source to filter the roles by. Available sources can be fetched using the \&#39;User Sources\&#39; endpoint.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRole(
      id: string,
      source?: string,
      options?: any,
    ): AxiosPromise<RoleXOResponse> {
      return SecurityManagementRolesApiFp(configuration)
        .getRole(id, source, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List roles
     * @param {string} [source] The id of the user source to filter the roles by, if supplied. Otherwise roles from all user sources will be returned.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getRoles(
      source?: string,
      options?: any,
    ): AxiosPromise<Array<RoleXOResponse>> {
      return SecurityManagementRolesApiFp(configuration)
        .getRoles(source, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update role
     * @param {string} id The id of the role to update
     * @param {RoleXORequest} body A role configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update1(
      id: string,
      body: RoleXORequest,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementRolesApiFp(configuration)
        .update1(id, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementRolesApi - object-oriented interface
 * @export
 * @class SecurityManagementRolesApi
 * @extends {BaseAPI}
 */
export class SecurityManagementRolesApi extends BaseAPI {
  /**
   *
   * @summary Delete role
   * @param {string} id The id of the role to delete
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRolesApi
   */
  public _delete(id: string, options?: any) {
    return SecurityManagementRolesApiFp(this.configuration)
      ._delete(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create role
   * @param {RoleXORequest} body A role configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRolesApi
   */
  public create(body: RoleXORequest, options?: any) {
    return SecurityManagementRolesApiFp(this.configuration)
      .create(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Get role
   * @param {string} id The id of the role to get
   * @param {string} [source] The id of the user source to filter the roles by. Available sources can be fetched using the \&#39;User Sources\&#39; endpoint.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRolesApi
   */
  public getRole(id: string, source?: string, options?: any) {
    return SecurityManagementRolesApiFp(this.configuration)
      .getRole(id, source, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List roles
   * @param {string} [source] The id of the user source to filter the roles by, if supplied. Otherwise roles from all user sources will be returned.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRolesApi
   */
  public getRoles(source?: string, options?: any) {
    return SecurityManagementRolesApiFp(this.configuration)
      .getRoles(source, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update role
   * @param {string} id The id of the role to update
   * @param {RoleXORequest} body A role configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementRolesApi
   */
  public update1(id: string, body: RoleXORequest, options?: any) {
    return SecurityManagementRolesApiFp(this.configuration)
      .update1(id, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SecurityManagementUsersApi - axios parameter creator
 * @export
 */
export const SecurityManagementUsersApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change a user\'s password.
     * @param {string} userId The userid the request should apply to.
     * @param {string} [body] The new password to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword: async (
      userId: string,
      body?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling changePassword.',
        )
      }
      const localVarPath = `/v1/security/users/{userId}/change-password`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'text/plain'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Create a new user in the default source.
     * @param {ApiCreateUser} [body] A representation of the user to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser: async (
      body?: ApiCreateUser,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/users`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Delete a user.
     * @param {string} userId The userid the request should apply to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser: async (
      userId: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling deleteUser.',
        )
      }
      const localVarPath = `/v1/security/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Retrieve a list of users. Note if the source is not \'default\' the response is limited to 100 users.
     * @param {string} [userId] An optional term to search userids for.
     * @param {string} [source] An optional user source to restrict the search to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers: async (
      userId?: string,
      source?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/security/users`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (userId !== undefined) {
        localVarQueryParameter['userId'] = userId
      }

      if (source !== undefined) {
        localVarQueryParameter['source'] = source
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Update an existing user.
     * @param {string} userId The userid the request should apply to.
     * @param {ApiUser} [body] A representation of the user to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser: async (
      userId: string,
      body?: ApiUser,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'userId' is not null or undefined
      if (userId === null || userId === undefined) {
        throw new RequiredError(
          'userId',
          'Required parameter userId was null or undefined when calling updateUser.',
        )
      }
      const localVarPath = `/v1/security/users/{userId}`.replace(
        `{${'userId'}}`,
        encodeURIComponent(String(userId)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SecurityManagementUsersApi - functional programming interface
 * @export
 */
export const SecurityManagementUsersApiFp = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Change a user\'s password.
     * @param {string} userId The userid the request should apply to.
     * @param {string} [body] The new password to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async changePassword(
      userId: string,
      body?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementUsersApiAxiosParamCreator(
        configuration,
      ).changePassword(userId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Create a new user in the default source.
     * @param {ApiCreateUser} [body] A representation of the user to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async createUser(
      body?: ApiCreateUser,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiUser>
    > {
      const localVarAxiosArgs = await SecurityManagementUsersApiAxiosParamCreator(
        configuration,
      ).createUser(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Delete a user.
     * @param {string} userId The userid the request should apply to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteUser(
      userId: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementUsersApiAxiosParamCreator(
        configuration,
      ).deleteUser(userId, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Retrieve a list of users. Note if the source is not \'default\' the response is limited to 100 users.
     * @param {string} [userId] An optional term to search userids for.
     * @param {string} [source] An optional user source to restrict the search to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getUsers(
      userId?: string,
      source?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ApiUser>>
    > {
      const localVarAxiosArgs = await SecurityManagementUsersApiAxiosParamCreator(
        configuration,
      ).getUsers(userId, source, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Update an existing user.
     * @param {string} userId The userid the request should apply to.
     * @param {ApiUser} [body] A representation of the user to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateUser(
      userId: string,
      body?: ApiUser,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SecurityManagementUsersApiAxiosParamCreator(
        configuration,
      ).updateUser(userId, body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SecurityManagementUsersApi - factory interface
 * @export
 */
export const SecurityManagementUsersApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Change a user\'s password.
     * @param {string} userId The userid the request should apply to.
     * @param {string} [body] The new password to use.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    changePassword(
      userId: string,
      body?: string,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementUsersApiFp(configuration)
        .changePassword(userId, body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Create a new user in the default source.
     * @param {ApiCreateUser} [body] A representation of the user to create.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createUser(body?: ApiCreateUser, options?: any): AxiosPromise<ApiUser> {
      return SecurityManagementUsersApiFp(configuration)
        .createUser(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Delete a user.
     * @param {string} userId The userid the request should apply to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteUser(userId: string, options?: any): AxiosPromise<void> {
      return SecurityManagementUsersApiFp(configuration)
        .deleteUser(userId, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Retrieve a list of users. Note if the source is not \'default\' the response is limited to 100 users.
     * @param {string} [userId] An optional term to search userids for.
     * @param {string} [source] An optional user source to restrict the search to.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getUsers(
      userId?: string,
      source?: string,
      options?: any,
    ): AxiosPromise<Array<ApiUser>> {
      return SecurityManagementUsersApiFp(configuration)
        .getUsers(userId, source, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Update an existing user.
     * @param {string} userId The userid the request should apply to.
     * @param {ApiUser} [body] A representation of the user to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateUser(
      userId: string,
      body?: ApiUser,
      options?: any,
    ): AxiosPromise<void> {
      return SecurityManagementUsersApiFp(configuration)
        .updateUser(userId, body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SecurityManagementUsersApi - object-oriented interface
 * @export
 * @class SecurityManagementUsersApi
 * @extends {BaseAPI}
 */
export class SecurityManagementUsersApi extends BaseAPI {
  /**
   *
   * @summary Change a user\'s password.
   * @param {string} userId The userid the request should apply to.
   * @param {string} [body] The new password to use.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementUsersApi
   */
  public changePassword(userId: string, body?: string, options?: any) {
    return SecurityManagementUsersApiFp(this.configuration)
      .changePassword(userId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Create a new user in the default source.
   * @param {ApiCreateUser} [body] A representation of the user to create.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementUsersApi
   */
  public createUser(body?: ApiCreateUser, options?: any) {
    return SecurityManagementUsersApiFp(this.configuration)
      .createUser(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Delete a user.
   * @param {string} userId The userid the request should apply to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementUsersApi
   */
  public deleteUser(userId: string, options?: any) {
    return SecurityManagementUsersApiFp(this.configuration)
      .deleteUser(userId, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Retrieve a list of users. Note if the source is not \'default\' the response is limited to 100 users.
   * @param {string} [userId] An optional term to search userids for.
   * @param {string} [source] An optional user source to restrict the search to.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementUsersApi
   */
  public getUsers(userId?: string, source?: string, options?: any) {
    return SecurityManagementUsersApiFp(this.configuration)
      .getUsers(userId, source, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Update an existing user.
   * @param {string} userId The userid the request should apply to.
   * @param {ApiUser} [body] A representation of the user to update.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SecurityManagementUsersApi
   */
  public updateUser(userId: string, body?: ApiUser, options?: any) {
    return SecurityManagementUsersApiFp(this.configuration)
      .updateUser(userId, body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Health check endpoint that returns the results of the system status checks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemStatusChecks: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status/check`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAvailable: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read and write requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isWritable: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1/status/writable`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Health check endpoint that returns the results of the system status checks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSystemStatusChecks(
      options?: any,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => AxiosPromise<{ [key: string]: Result }>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration,
      ).getSystemStatusChecks(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isAvailable(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration,
      ).isAvailable(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read and write requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async isWritable(
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await StatusApiAxiosParamCreator(
        configuration,
      ).isWritable(options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Health check endpoint that returns the results of the system status checks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSystemStatusChecks(
      options?: any,
    ): AxiosPromise<{ [key: string]: Result }> {
      return StatusApiFp(configuration)
        .getSystemStatusChecks(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isAvailable(options?: any): AxiosPromise<void> {
      return StatusApiFp(configuration)
        .isAvailable(options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Health check endpoint that validates server can respond to read and write requests
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    isWritable(options?: any): AxiosPromise<void> {
      return StatusApiFp(configuration)
        .isWritable(options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
  /**
   *
   * @summary Health check endpoint that returns the results of the system status checks
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public getSystemStatusChecks(options?: any) {
    return StatusApiFp(this.configuration)
      .getSystemStatusChecks(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Health check endpoint that validates server can respond to read requests
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public isAvailable(options?: any) {
    return StatusApiFp(this.configuration)
      .isAvailable(options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Health check endpoint that validates server can respond to read and write requests
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StatusApi
   */
  public isWritable(options?: any) {
    return StatusApiFp(this.configuration)
      .isWritable(options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * SupportApi - axios parameter creator
 * @export
 */
export const SupportApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Creates and downloads a support zip
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportzip: async (
      body?: Request,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/support/supportzip`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Creates a support zip and returns the path
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportzippath: async (
      body?: Request,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/support/supportzippath`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarHeaderParameter['Content-Type'] = 'application/json'

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json'
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || ''

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * SupportApi - functional programming interface
 * @export
 */
export const SupportApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Creates and downloads a support zip
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async supportzip(
      body?: Request,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await SupportApiAxiosParamCreator(
        configuration,
      ).supportzip(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Creates a support zip and returns the path
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async supportzippath(
      body?: Request,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportZipXO>
    > {
      const localVarAxiosArgs = await SupportApiAxiosParamCreator(
        configuration,
      ).supportzippath(body, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * SupportApi - factory interface
 * @export
 */
export const SupportApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Creates and downloads a support zip
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportzip(body?: Request, options?: any): AxiosPromise<void> {
      return SupportApiFp(configuration)
        .supportzip(body, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Creates a support zip and returns the path
     * @param {Request} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    supportzippath(body?: Request, options?: any): AxiosPromise<SupportZipXO> {
      return SupportApiFp(configuration)
        .supportzippath(body, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * SupportApi - object-oriented interface
 * @export
 * @class SupportApi
 * @extends {BaseAPI}
 */
export class SupportApi extends BaseAPI {
  /**
   *
   * @summary Creates and downloads a support zip
   * @param {Request} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public supportzip(body?: Request, options?: any) {
    return SupportApiFp(this.configuration)
      .supportzip(body, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Creates a support zip and returns the path
   * @param {Request} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SupportApi
   */
  public supportzippath(body?: Request, options?: any) {
    return SupportApiFp(this.configuration)
      .supportzippath(body, options)
      .then((request) => request(this.axios, this.basePath))
  }
}

/**
 * TasksApi - axios parameter creator
 * @export
 */
export const TasksApiAxiosParamCreator = function (
  configuration?: Configuration,
) {
  return {
    /**
     *
     * @summary Get a single task by id
     * @param {string} id Id of the task to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskById: async (
      id: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling getTaskById.',
        )
      }
      const localVarPath = `/v1/tasks/{id}`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary List tasks
     * @param {string} [type] Type of the tasks to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks: async (
      type?: string,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v1/tasks`
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'GET',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      if (type !== undefined) {
        localVarQueryParameter['type'] = type
      }

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Run task
     * @param {string} id Id of the task to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    run: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling run.',
        )
      }
      const localVarPath = `/v1/tasks/{id}/run`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
    /**
     *
     * @summary Stop task
     * @param {string} id Id of the task to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stop: async (id: string, options: any = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      if (id === null || id === undefined) {
        throw new RequiredError(
          'id',
          'Required parameter id was null or undefined when calling stop.',
        )
      }
      const localVarPath = `/v1/tasks/{id}/stop`.replace(
        `{${'id'}}`,
        encodeURIComponent(String(id)),
      )
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true)
      let baseOptions
      if (configuration) {
        baseOptions = configuration.baseOptions
      }
      const localVarRequestOptions = {
        method: 'POST',
        ...baseOptions,
        ...options,
      }
      const localVarHeaderParameter = {} as any
      const localVarQueryParameter = {} as any

      localVarUrlObj.query = {
        ...localVarUrlObj.query,
        ...localVarQueryParameter,
        ...options.query,
      }
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {}
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      }

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      }
    },
  }
}

/**
 * TasksApi - functional programming interface
 * @export
 */
export const TasksApiFp = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Get a single task by id
     * @param {string} id Id of the task to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTaskById(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaskXO>
    > {
      const localVarAxiosArgs = await TasksApiAxiosParamCreator(
        configuration,
      ).getTaskById(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary List tasks
     * @param {string} [type] Type of the tasks to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getTasks(
      type?: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageTaskXO>
    > {
      const localVarAxiosArgs = await TasksApiAxiosParamCreator(
        configuration,
      ).getTasks(type, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Run task
     * @param {string} id Id of the task to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async run(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TasksApiAxiosParamCreator(
        configuration,
      ).run(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
    /**
     *
     * @summary Stop task
     * @param {string} id Id of the task to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async stop(
      id: string,
      options?: any,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await TasksApiAxiosParamCreator(
        configuration,
      ).stop(id, options)
      return (
        axios: AxiosInstance = globalAxios,
        basePath: string = BASE_PATH,
      ) => {
        const axiosRequestArgs = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        }
        return axios.request(axiosRequestArgs)
      }
    },
  }
}

/**
 * TasksApi - factory interface
 * @export
 */
export const TasksApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     *
     * @summary Get a single task by id
     * @param {string} id Id of the task to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTaskById(id: string, options?: any): AxiosPromise<TaskXO> {
      return TasksApiFp(configuration)
        .getTaskById(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary List tasks
     * @param {string} [type] Type of the tasks to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getTasks(type?: string, options?: any): AxiosPromise<PageTaskXO> {
      return TasksApiFp(configuration)
        .getTasks(type, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Run task
     * @param {string} id Id of the task to run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    run(id: string, options?: any): AxiosPromise<void> {
      return TasksApiFp(configuration)
        .run(id, options)
        .then((request) => request(axios, basePath))
    },
    /**
     *
     * @summary Stop task
     * @param {string} id Id of the task to stop
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    stop(id: string, options?: any): AxiosPromise<void> {
      return TasksApiFp(configuration)
        .stop(id, options)
        .then((request) => request(axios, basePath))
    },
  }
}

/**
 * TasksApi - object-oriented interface
 * @export
 * @class TasksApi
 * @extends {BaseAPI}
 */
export class TasksApi extends BaseAPI {
  /**
   *
   * @summary Get a single task by id
   * @param {string} id Id of the task to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTaskById(id: string, options?: any) {
    return TasksApiFp(this.configuration)
      .getTaskById(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary List tasks
   * @param {string} [type] Type of the tasks to get
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public getTasks(type?: string, options?: any) {
    return TasksApiFp(this.configuration)
      .getTasks(type, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Run task
   * @param {string} id Id of the task to run
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public run(id: string, options?: any) {
    return TasksApiFp(this.configuration)
      .run(id, options)
      .then((request) => request(this.axios, this.basePath))
  }

  /**
   *
   * @summary Stop task
   * @param {string} id Id of the task to stop
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TasksApi
   */
  public stop(id: string, options?: any) {
    return TasksApiFp(this.configuration)
      .stop(id, options)
      .then((request) => request(this.axios, this.basePath))
  }
}
